{"ast":null,"code":"'use strict';\n\n/**\n * @license Angular v<unknown>\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n/**\n * @fileoverview\n * @suppress {globalThis}\n */\nconst NEWLINE = '\\n';\nconst IGNORE_FRAMES = {};\nconst creationTrace = '__creationTrace__';\nconst ERROR_TAG = 'STACKTRACE TRACKING';\nconst SEP_TAG = '__SEP_TAG__';\nlet sepTemplate = SEP_TAG + '@[native]';\nclass LongStackTrace {\n  constructor() {\n    this.error = getStacktrace();\n    this.timestamp = new Date();\n  }\n}\nfunction getStacktraceWithUncaughtError() {\n  return new Error(ERROR_TAG);\n}\nfunction getStacktraceWithCaughtError() {\n  try {\n    throw getStacktraceWithUncaughtError();\n  } catch (err) {\n    return err;\n  }\n}\n// Some implementations of exception handling don't create a stack trace if the exception\n// isn't thrown, however it's faster not to actually throw the exception.\nconst error = getStacktraceWithUncaughtError();\nconst caughtError = getStacktraceWithCaughtError();\nconst getStacktrace = error.stack ? getStacktraceWithUncaughtError : caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError;\nfunction getFrames(error) {\n  return error.stack ? error.stack.split(NEWLINE) : [];\n}\nfunction addErrorStack(lines, error) {\n  let trace = getFrames(error);\n  for (let i = 0; i < trace.length; i++) {\n    const frame = trace[i];\n    // Filter out the Frames which are part of stack capturing.\n    if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n      lines.push(trace[i]);\n    }\n  }\n}\nfunction renderLongStackTrace(frames, stack) {\n  const longTrace = [stack ? stack.trim() : ''];\n  if (frames) {\n    let timestamp = new Date().getTime();\n    for (let i = 0; i < frames.length; i++) {\n      const traceFrames = frames[i];\n      const lastTime = traceFrames.timestamp;\n      let separator = `____________________Elapsed ${timestamp - lastTime.getTime()} ms; At: ${lastTime}`;\n      separator = separator.replace(/[^\\w\\d]/g, '_');\n      longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n      addErrorStack(longTrace, traceFrames.error);\n      timestamp = lastTime.getTime();\n    }\n  }\n  return longTrace.join(NEWLINE);\n}\n// if Error.stackTraceLimit is 0, means stack trace\n// is disabled, so we don't need to generate long stack trace\n// this will improve performance in some test(some test will\n// set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\nfunction stackTracesEnabled() {\n  // Cast through any since this property only exists on Error in the nodejs\n  // typings.\n  return Error.stackTraceLimit > 0;\n}\nZone['longStackTraceZoneSpec'] = {\n  name: 'long-stack-trace',\n  longStackTraceLimit: 10,\n  // Max number of task to keep the stack trace for.\n  // add a getLongStackTrace method in spec to\n  // handle handled reject promise error.\n  getLongStackTrace: function (error) {\n    if (!error) {\n      return undefined;\n    }\n    const trace = error[Zone.__symbol__('currentTaskTrace')];\n    if (!trace) {\n      return error.stack;\n    }\n    return renderLongStackTrace(trace, error.stack);\n  },\n  onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n    if (stackTracesEnabled()) {\n      const currentTask = Zone.currentTask;\n      let trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n      trace = [new LongStackTrace()].concat(trace);\n      if (trace.length > this.longStackTraceLimit) {\n        trace.length = this.longStackTraceLimit;\n      }\n      if (!task.data) task.data = {};\n      if (task.type === 'eventTask') {\n        // Fix issue https://github.com/angular/zone.js/issues/1195,\n        // For event task of browser, by default, all task will share a\n        // singleton instance of data object, we should create a new one here\n        // The cast to `any` is required to workaround a closure bug which wrongly applies\n        // URL sanitization rules to .data access.\n        task.data = {\n          ...task.data\n        };\n      }\n      task.data[creationTrace] = trace;\n    }\n    return parentZoneDelegate.scheduleTask(targetZone, task);\n  },\n  onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n    if (stackTracesEnabled()) {\n      const parentTask = Zone.currentTask || error.task;\n      if (error instanceof Error && parentTask) {\n        const longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n        try {\n          error.stack = error.longStack = longStack;\n        } catch (err) {}\n      }\n    }\n    return parentZoneDelegate.handleError(targetZone, error);\n  }\n};\nfunction captureStackTraces(stackTraces, count) {\n  if (count > 0) {\n    stackTraces.push(getFrames(new LongStackTrace().error));\n    captureStackTraces(stackTraces, count - 1);\n  }\n}\nfunction computeIgnoreFrames() {\n  if (!stackTracesEnabled()) {\n    return;\n  }\n  const frames = [];\n  captureStackTraces(frames, 2);\n  const frames1 = frames[0];\n  const frames2 = frames[1];\n  for (let i = 0; i < frames1.length; i++) {\n    const frame1 = frames1[i];\n    if (frame1.indexOf(ERROR_TAG) == -1) {\n      let match = frame1.match(/^\\s*at\\s+/);\n      if (match) {\n        sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < frames1.length; i++) {\n    const frame1 = frames1[i];\n    const frame2 = frames2[i];\n    if (frame1 === frame2) {\n      IGNORE_FRAMES[frame1] = true;\n    } else {\n      break;\n    }\n  }\n}\ncomputeIgnoreFrames();\nclass ProxyZoneSpec {\n  static get() {\n    return Zone.current.get('ProxyZoneSpec');\n  }\n  static isLoaded() {\n    return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n  }\n  static assertPresent() {\n    if (!ProxyZoneSpec.isLoaded()) {\n      throw new Error(`Expected to be running in 'ProxyZone', but it was not found.`);\n    }\n    return ProxyZoneSpec.get();\n  }\n  constructor(defaultSpecDelegate = null) {\n    this.defaultSpecDelegate = defaultSpecDelegate;\n    this.name = 'ProxyZone';\n    this._delegateSpec = null;\n    this.properties = {\n      'ProxyZoneSpec': this\n    };\n    this.propertyKeys = null;\n    this.lastTaskState = null;\n    this.isNeedToTriggerHasTask = false;\n    this.tasks = [];\n    this.setDelegate(defaultSpecDelegate);\n  }\n  setDelegate(delegateSpec) {\n    const isNewDelegate = this._delegateSpec !== delegateSpec;\n    this._delegateSpec = delegateSpec;\n    this.propertyKeys && this.propertyKeys.forEach(key => delete this.properties[key]);\n    this.propertyKeys = null;\n    if (delegateSpec && delegateSpec.properties) {\n      this.propertyKeys = Object.keys(delegateSpec.properties);\n      this.propertyKeys.forEach(k => this.properties[k] = delegateSpec.properties[k]);\n    }\n    // if a new delegateSpec was set, check if we need to trigger hasTask\n    if (isNewDelegate && this.lastTaskState && (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n      this.isNeedToTriggerHasTask = true;\n    }\n  }\n  getDelegate() {\n    return this._delegateSpec;\n  }\n  resetDelegate() {\n    this.getDelegate();\n    this.setDelegate(this.defaultSpecDelegate);\n  }\n  tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone) {\n    if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n      // last delegateSpec has microTask or macroTask\n      // should call onHasTask in current delegateSpec\n      this.isNeedToTriggerHasTask = false;\n      this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n    }\n  }\n  removeFromTasks(task) {\n    if (!this.tasks) {\n      return;\n    }\n    for (let i = 0; i < this.tasks.length; i++) {\n      if (this.tasks[i] === task) {\n        this.tasks.splice(i, 1);\n        return;\n      }\n    }\n  }\n  getAndClearPendingTasksInfo() {\n    if (this.tasks.length === 0) {\n      return '';\n    }\n    const taskInfo = this.tasks.map(task => {\n      const dataInfo = task.data && Object.keys(task.data).map(key => {\n        return key + ':' + task.data[key];\n      }).join(',');\n      return `type: ${task.type}, source: ${task.source}, args: {${dataInfo}}`;\n    });\n    const pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']';\n    // clear tasks\n    this.tasks = [];\n    return pendingTasksInfo;\n  }\n  onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n    if (this._delegateSpec && this._delegateSpec.onFork) {\n      return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n    } else {\n      return parentZoneDelegate.fork(targetZone, zoneSpec);\n    }\n  }\n  onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source) {\n    if (this._delegateSpec && this._delegateSpec.onIntercept) {\n      return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n    } else {\n      return parentZoneDelegate.intercept(targetZone, delegate, source);\n    }\n  }\n  onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n    this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n    if (this._delegateSpec && this._delegateSpec.onInvoke) {\n      return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n    } else {\n      return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n    }\n  }\n  onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n    if (this._delegateSpec && this._delegateSpec.onHandleError) {\n      return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n    } else {\n      return parentZoneDelegate.handleError(targetZone, error);\n    }\n  }\n  onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n    if (task.type !== 'eventTask') {\n      this.tasks.push(task);\n    }\n    if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n      return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n    } else {\n      return parentZoneDelegate.scheduleTask(targetZone, task);\n    }\n  }\n  onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n    if (task.type !== 'eventTask') {\n      this.removeFromTasks(task);\n    }\n    this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n    if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n      return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n    } else {\n      return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n    }\n  }\n  onCancelTask(parentZoneDelegate, currentZone, targetZone, task) {\n    if (task.type !== 'eventTask') {\n      this.removeFromTasks(task);\n    }\n    this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n    if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n      return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n    } else {\n      return parentZoneDelegate.cancelTask(targetZone, task);\n    }\n  }\n  onHasTask(delegate, current, target, hasTaskState) {\n    this.lastTaskState = hasTaskState;\n    if (this._delegateSpec && this._delegateSpec.onHasTask) {\n      this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n    } else {\n      delegate.hasTask(target, hasTaskState);\n    }\n  }\n}\n// Export the class so that new instances can be created with proper\n// constructor params.\nZone['ProxyZoneSpec'] = ProxyZoneSpec;\nclass SyncTestZoneSpec {\n  constructor(namePrefix) {\n    this.runZone = Zone.current;\n    this.name = 'syncTestZone for ' + namePrefix;\n  }\n  onScheduleTask(delegate, current, target, task) {\n    switch (task.type) {\n      case 'microTask':\n      case 'macroTask':\n        throw new Error(`Cannot call ${task.source} from within a sync test (${this.name}).`);\n      case 'eventTask':\n        task = delegate.scheduleTask(target, task);\n        break;\n    }\n    return task;\n  }\n}\n// Export the class so that new instances can be created with proper\n// constructor params.\nZone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n\n/// <reference types=\"jasmine\"/>\nZone.__load_patch('jasmine', (global, Zone, api) => {\n  const __extends = function (d, b) {\n    for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n  // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n  // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n  if (!Zone) throw new Error('Missing: zone.js');\n  if (typeof jest !== 'undefined') {\n    // return if jasmine is a light implementation inside jest\n    // in this case, we are running inside jest not jasmine\n    return;\n  }\n  if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n    return;\n  }\n  jasmine['__zone_patch__'] = true;\n  const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n  const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n  if (!SyncTestZoneSpec) throw new Error('Missing: SyncTestZoneSpec');\n  if (!ProxyZoneSpec) throw new Error('Missing: ProxyZoneSpec');\n  const ambientZone = Zone.current;\n  const symbol = Zone.__symbol__;\n  // whether patch jasmine clock when in fakeAsync\n  const disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true;\n  // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n  // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n  // automatically disable the auto jump into fakeAsync feature\n  const enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock && (global[symbol('fakeAsyncPatchLock')] === true || global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true);\n  const ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n  if (!ignoreUnhandledRejection) {\n    const globalErrors = jasmine.GlobalErrors;\n    if (globalErrors && !jasmine[symbol('GlobalErrors')]) {\n      jasmine[symbol('GlobalErrors')] = globalErrors;\n      jasmine.GlobalErrors = function () {\n        const instance = new globalErrors();\n        const originalInstall = instance.install;\n        if (originalInstall && !instance[symbol('install')]) {\n          instance[symbol('install')] = originalInstall;\n          instance.install = function () {\n            const isNode = typeof process !== 'undefined' && !!process.on;\n            // Note: Jasmine checks internally if `process` and `process.on` is defined. Otherwise,\n            // it installs the browser rejection handler through the `global.addEventListener`.\n            // This code may be run in the browser environment where `process` is not defined, and\n            // this will lead to a runtime exception since Webpack 5 removed automatic Node.js\n            // polyfills. Note, that events are named differently, it's `unhandledRejection` in\n            // Node.js and `unhandledrejection` in the browser.\n            const originalHandlers = isNode ? process.listeners('unhandledRejection') : global.eventListeners('unhandledrejection');\n            const result = originalInstall.apply(this, arguments);\n            isNode ? process.removeAllListeners('unhandledRejection') : global.removeAllListeners('unhandledrejection');\n            if (originalHandlers) {\n              originalHandlers.forEach(handler => {\n                if (isNode) {\n                  process.on('unhandledRejection', handler);\n                } else {\n                  global.addEventListener('unhandledrejection', handler);\n                }\n              });\n            }\n            return result;\n          };\n        }\n        return instance;\n      };\n    }\n  }\n  // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n  const jasmineEnv = jasmine.getEnv();\n  ['describe', 'xdescribe', 'fdescribe'].forEach(methodName => {\n    let originalJasmineFn = jasmineEnv[methodName];\n    jasmineEnv[methodName] = function (description, specDefinitions) {\n      return originalJasmineFn.call(this, description, wrapDescribeInZone(description, specDefinitions));\n    };\n  });\n  ['it', 'xit', 'fit'].forEach(methodName => {\n    let originalJasmineFn = jasmineEnv[methodName];\n    jasmineEnv[symbol(methodName)] = originalJasmineFn;\n    jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n      arguments[1] = wrapTestInZone(specDefinitions);\n      return originalJasmineFn.apply(this, arguments);\n    };\n  });\n  ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(methodName => {\n    let originalJasmineFn = jasmineEnv[methodName];\n    jasmineEnv[symbol(methodName)] = originalJasmineFn;\n    jasmineEnv[methodName] = function (specDefinitions, timeout) {\n      arguments[0] = wrapTestInZone(specDefinitions);\n      return originalJasmineFn.apply(this, arguments);\n    };\n  });\n  if (!disablePatchingJasmineClock) {\n    // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n    // they can work properly in FakeAsyncTest\n    const originalClockFn = jasmine[symbol('clock')] = jasmine['clock'];\n    jasmine['clock'] = function () {\n      const clock = originalClockFn.apply(this, arguments);\n      if (!clock[symbol('patched')]) {\n        clock[symbol('patched')] = symbol('patched');\n        const originalTick = clock[symbol('tick')] = clock.tick;\n        clock.tick = function () {\n          const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n          if (fakeAsyncZoneSpec) {\n            return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n          }\n          return originalTick.apply(this, arguments);\n        };\n        const originalMockDate = clock[symbol('mockDate')] = clock.mockDate;\n        clock.mockDate = function () {\n          const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n          if (fakeAsyncZoneSpec) {\n            const dateTime = arguments.length > 0 ? arguments[0] : new Date();\n            return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] : arguments);\n          }\n          return originalMockDate.apply(this, arguments);\n        };\n        // for auto go into fakeAsync feature, we need the flag to enable it\n        if (enableAutoFakeAsyncWhenClockPatched) {\n          ['install', 'uninstall'].forEach(methodName => {\n            const originalClockFn = clock[symbol(methodName)] = clock[methodName];\n            clock[methodName] = function () {\n              const FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n              if (FakeAsyncTestZoneSpec) {\n                jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                return;\n              }\n              return originalClockFn.apply(this, arguments);\n            };\n          });\n        }\n      }\n      return clock;\n    };\n  }\n  // monkey patch createSpyObj to make properties enumerable to true\n  if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n    const originalCreateSpyObj = jasmine.createSpyObj;\n    jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj;\n    jasmine.createSpyObj = function () {\n      const args = Array.prototype.slice.call(arguments);\n      const propertyNames = args.length >= 3 ? args[2] : null;\n      let spyObj;\n      if (propertyNames) {\n        const defineProperty = Object.defineProperty;\n        Object.defineProperty = function (obj, p, attributes) {\n          return defineProperty.call(this, obj, p, {\n            ...attributes,\n            configurable: true,\n            enumerable: true\n          });\n        };\n        try {\n          spyObj = originalCreateSpyObj.apply(this, args);\n        } finally {\n          Object.defineProperty = defineProperty;\n        }\n      } else {\n        spyObj = originalCreateSpyObj.apply(this, args);\n      }\n      return spyObj;\n    };\n  }\n  /**\n   * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n   * synchronous-only zone.\n   */\n  function wrapDescribeInZone(description, describeBody) {\n    return function () {\n      // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n      // error if any asynchronous operations are attempted inside of a `describe`.\n      const syncZone = ambientZone.fork(new SyncTestZoneSpec(`jasmine.describe#${description}`));\n      return syncZone.run(describeBody, this, arguments);\n    };\n  }\n  function runInTestZone(testBody, applyThis, queueRunner, done) {\n    const isClockInstalled = !!jasmine[symbol('clockInstalled')];\n    queueRunner.testProxyZoneSpec;\n    const testProxyZone = queueRunner.testProxyZone;\n    if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n      // auto run a fakeAsync\n      const fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n      if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n        testBody = fakeAsyncModule.fakeAsync(testBody);\n      }\n    }\n    if (done) {\n      return testProxyZone.run(testBody, applyThis, [done]);\n    } else {\n      return testProxyZone.run(testBody, applyThis);\n    }\n  }\n  /**\n   * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n   * execute in a ProxyZone zone.\n   * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n   */\n  function wrapTestInZone(testBody) {\n    // The `done` callback is only passed through if the function expects at least one argument.\n    // Note we have to make a function with correct number of arguments, otherwise jasmine will\n    // think that all functions are sync or async.\n    return testBody && (testBody.length ? function (done) {\n      return runInTestZone(testBody, this, this.queueRunner, done);\n    } : function () {\n      return runInTestZone(testBody, this, this.queueRunner);\n    });\n  }\n  const QueueRunner = jasmine.QueueRunner;\n  jasmine.QueueRunner = function (_super) {\n    __extends(ZoneQueueRunner, _super);\n    function ZoneQueueRunner(attrs) {\n      if (attrs.onComplete) {\n        attrs.onComplete = (fn => () => {\n          // All functions are done, clear the test zone.\n          this.testProxyZone = null;\n          this.testProxyZoneSpec = null;\n          ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n        })(attrs.onComplete);\n      }\n      const nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n      const nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n      if (nativeSetTimeout) {\n        // should run setTimeout inside jasmine outside of zone\n        attrs.timeout = {\n          setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n          clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n        };\n      }\n      // create a userContext to hold the queueRunner itself\n      // so we can access the testProxy in it/xit/beforeEach ...\n      if (jasmine.UserContext) {\n        if (!attrs.userContext) {\n          attrs.userContext = new jasmine.UserContext();\n        }\n        attrs.userContext.queueRunner = this;\n      } else {\n        if (!attrs.userContext) {\n          attrs.userContext = {};\n        }\n        attrs.userContext.queueRunner = this;\n      }\n      // patch attrs.onException\n      const onException = attrs.onException;\n      attrs.onException = function (error) {\n        if (error && error.message === 'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n          // jasmine timeout, we can make the error message more\n          // reasonable to tell what tasks are pending\n          const proxyZoneSpec = this && this.testProxyZoneSpec;\n          if (proxyZoneSpec) {\n            const pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n            try {\n              // try catch here in case error.message is not writable\n              error.message += pendingTasksInfo;\n            } catch (err) {}\n          }\n        }\n        if (onException) {\n          onException.call(this, error);\n        }\n      };\n      _super.call(this, attrs);\n    }\n    ZoneQueueRunner.prototype.execute = function () {\n      let zone = Zone.current;\n      let isChildOfAmbientZone = false;\n      while (zone) {\n        if (zone === ambientZone) {\n          isChildOfAmbientZone = true;\n          break;\n        }\n        zone = zone.parent;\n      }\n      if (!isChildOfAmbientZone) throw new Error('Unexpected Zone: ' + Zone.current.name);\n      // This is the zone which will be used for running individual tests.\n      // It will be a proxy zone, so that the tests function can retroactively install\n      // different zones.\n      // Example:\n      //   - In beforeEach() do childZone = Zone.current.fork(...);\n      //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n      //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n      //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n      //     fakeAsync behavior to the childZone.\n      this.testProxyZoneSpec = new ProxyZoneSpec();\n      this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n      if (!Zone.currentTask) {\n        // if we are not running in a task then if someone would register a\n        // element.addEventListener and then calling element.click() the\n        // addEventListener callback would think that it is the top most task and would\n        // drain the microtask queue on element.click() which would be incorrect.\n        // For this reason we always force a task when running jasmine tests.\n        Zone.current.scheduleMicroTask('jasmine.execute().forceTask', () => QueueRunner.prototype.execute.call(this));\n      } else {\n        _super.prototype.execute.call(this);\n      }\n    };\n    return ZoneQueueRunner;\n  }(QueueRunner);\n});\nZone.__load_patch('jest', (context, Zone, api) => {\n  if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n    return;\n  }\n  // From jest 29 and jest-preset-angular v13, the module transform logic\n  // changed, and now jest-preset-angular use the use the tsconfig target\n  // other than the hardcoded one, https://github.com/thymikee/jest-preset-angular/issues/2010\n  // But jest-angular-preset doesn't introduce the @babel/plugin-transform-async-to-generator\n  // which is needed by angular since `async/await` still need to be transformed\n  // to promise for ES2017+ target.\n  // So for now, we disable to output the uncaught error console log for a temp solution,\n  // until jest-preset-angular find a proper solution.\n  Zone[api.symbol('ignoreConsoleErrorUncaughtError')] = true;\n  jest['__zone_patch__'] = true;\n  const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n  const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n  if (!ProxyZoneSpec) {\n    throw new Error('Missing ProxyZoneSpec');\n  }\n  const rootZone = Zone.current;\n  const syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n  const proxyZoneSpec = new ProxyZoneSpec();\n  const proxyZone = rootZone.fork(proxyZoneSpec);\n  function wrapDescribeFactoryInZone(originalJestFn) {\n    return function (...tableArgs) {\n      const originalDescribeFn = originalJestFn.apply(this, tableArgs);\n      return function (...args) {\n        args[1] = wrapDescribeInZone(args[1]);\n        return originalDescribeFn.apply(this, args);\n      };\n    };\n  }\n  function wrapTestFactoryInZone(originalJestFn) {\n    return function (...tableArgs) {\n      return function (...args) {\n        args[1] = wrapTestInZone(args[1]);\n        return originalJestFn.apply(this, tableArgs).apply(this, args);\n      };\n    };\n  }\n  /**\n   * Gets a function wrapping the body of a jest `describe` block to execute in a\n   * synchronous-only zone.\n   */\n  function wrapDescribeInZone(describeBody) {\n    return function (...args) {\n      return syncZone.run(describeBody, this, args);\n    };\n  }\n  /**\n   * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n   * execute in a ProxyZone zone.\n   * This will run in the `proxyZone`.\n   */\n  function wrapTestInZone(testBody, isTestFunc = false) {\n    if (typeof testBody !== 'function') {\n      return testBody;\n    }\n    const wrappedFunc = function () {\n      if (Zone[api.symbol('useFakeTimersCalled')] === true && testBody && !testBody.isFakeAsync) {\n        // jest.useFakeTimers is called, run into fakeAsyncTest automatically.\n        const fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n        if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n          testBody = fakeAsyncModule.fakeAsync(testBody);\n        }\n      }\n      proxyZoneSpec.isTestFunc = isTestFunc;\n      return proxyZone.run(testBody, null, arguments);\n    };\n    // Update the length of wrappedFunc to be the same as the length of the testBody\n    // So jest core can handle whether the test function has `done()` or not correctly\n    Object.defineProperty(wrappedFunc, 'length', {\n      configurable: true,\n      writable: true,\n      enumerable: false\n    });\n    wrappedFunc.length = testBody.length;\n    return wrappedFunc;\n  }\n  ['describe', 'xdescribe', 'fdescribe'].forEach(methodName => {\n    let originalJestFn = context[methodName];\n    if (context[Zone.__symbol__(methodName)]) {\n      return;\n    }\n    context[Zone.__symbol__(methodName)] = originalJestFn;\n    context[methodName] = function (...args) {\n      args[1] = wrapDescribeInZone(args[1]);\n      return originalJestFn.apply(this, args);\n    };\n    context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n  });\n  context.describe.only = context.fdescribe;\n  context.describe.skip = context.xdescribe;\n  ['it', 'xit', 'fit', 'test', 'xtest'].forEach(methodName => {\n    let originalJestFn = context[methodName];\n    if (context[Zone.__symbol__(methodName)]) {\n      return;\n    }\n    context[Zone.__symbol__(methodName)] = originalJestFn;\n    context[methodName] = function (...args) {\n      args[1] = wrapTestInZone(args[1], true);\n      return originalJestFn.apply(this, args);\n    };\n    context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n    context[methodName].todo = originalJestFn.todo;\n  });\n  context.it.only = context.fit;\n  context.it.skip = context.xit;\n  context.test.only = context.fit;\n  context.test.skip = context.xit;\n  ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(methodName => {\n    let originalJestFn = context[methodName];\n    if (context[Zone.__symbol__(methodName)]) {\n      return;\n    }\n    context[Zone.__symbol__(methodName)] = originalJestFn;\n    context[methodName] = function (...args) {\n      args[0] = wrapTestInZone(args[0]);\n      return originalJestFn.apply(this, args);\n    };\n  });\n  Zone.patchJestObject = function patchJestObject(Timer, isModern = false) {\n    // check whether currently the test is inside fakeAsync()\n    function isPatchingFakeTimer() {\n      const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n      return !!fakeAsyncZoneSpec;\n    }\n    // check whether the current function is inside `test/it` or other methods\n    // such as `describe/beforeEach`\n    function isInTestFunc() {\n      const proxyZoneSpec = Zone.current.get('ProxyZoneSpec');\n      return proxyZoneSpec && proxyZoneSpec.isTestFunc;\n    }\n    if (Timer[api.symbol('fakeTimers')]) {\n      return;\n    }\n    Timer[api.symbol('fakeTimers')] = true;\n    // patch jest fakeTimer internal method to make sure no console.warn print out\n    api.patchMethod(Timer, '_checkFakeTimers', delegate => {\n      return function (self, args) {\n        if (isPatchingFakeTimer()) {\n          return true;\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    });\n    // patch useFakeTimers(), set useFakeTimersCalled flag, and make test auto run into fakeAsync\n    api.patchMethod(Timer, 'useFakeTimers', delegate => {\n      return function (self, args) {\n        Zone[api.symbol('useFakeTimersCalled')] = true;\n        if (isModern || isInTestFunc()) {\n          return delegate.apply(self, args);\n        }\n        return self;\n      };\n    });\n    // patch useRealTimers(), unset useFakeTimers flag\n    api.patchMethod(Timer, 'useRealTimers', delegate => {\n      return function (self, args) {\n        Zone[api.symbol('useFakeTimersCalled')] = false;\n        if (isModern || isInTestFunc()) {\n          return delegate.apply(self, args);\n        }\n        return self;\n      };\n    });\n    // patch setSystemTime(), call setCurrentRealTime() in the fakeAsyncTest\n    api.patchMethod(Timer, 'setSystemTime', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n          fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    });\n    // patch getSystemTime(), call getCurrentRealTime() in the fakeAsyncTest\n    api.patchMethod(Timer, 'getRealSystemTime', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n          return fakeAsyncZoneSpec.getRealSystemTime();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    });\n    // patch runAllTicks(), run all microTasks inside fakeAsync\n    api.patchMethod(Timer, 'runAllTicks', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.flushMicrotasks();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    });\n    // patch runAllTimers(), run all macroTasks inside fakeAsync\n    api.patchMethod(Timer, 'runAllTimers', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.flush(100, true);\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    });\n    // patch advanceTimersByTime(), call tick() in the fakeAsyncTest\n    api.patchMethod(Timer, 'advanceTimersByTime', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.tick(args[0]);\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    });\n    // patch runOnlyPendingTimers(), call flushOnlyPendingTimers() in the fakeAsyncTest\n    api.patchMethod(Timer, 'runOnlyPendingTimers', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.flushOnlyPendingTimers();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    });\n    // patch advanceTimersToNextTimer(), call tickToNext() in the fakeAsyncTest\n    api.patchMethod(Timer, 'advanceTimersToNextTimer', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.tickToNext(args[0]);\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    });\n    // patch clearAllTimers(), call removeAllTimers() in the fakeAsyncTest\n    api.patchMethod(Timer, 'clearAllTimers', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.removeAllTimers();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    });\n    // patch getTimerCount(), call getTimerCount() in the fakeAsyncTest\n    api.patchMethod(Timer, 'getTimerCount', delegate => {\n      return function (self, args) {\n        const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        if (fakeAsyncZoneSpec) {\n          return fakeAsyncZoneSpec.getTimerCount();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    });\n  };\n});\nZone.__load_patch('mocha', (global, Zone) => {\n  const Mocha = global.Mocha;\n  if (typeof Mocha === 'undefined') {\n    // return if Mocha is not available, because now zone-testing\n    // will load mocha patch with jasmine/jest patch\n    return;\n  }\n  if (typeof Zone === 'undefined') {\n    throw new Error('Missing Zone.js');\n  }\n  const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n  const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n  if (!ProxyZoneSpec) {\n    throw new Error('Missing ProxyZoneSpec');\n  }\n  if (Mocha['__zone_patch__']) {\n    throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n  }\n  Mocha['__zone_patch__'] = true;\n  const rootZone = Zone.current;\n  const syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n  let testZone = null;\n  const suiteZone = rootZone.fork(new ProxyZoneSpec());\n  const mochaOriginal = {\n    after: global.after,\n    afterEach: global.afterEach,\n    before: global.before,\n    beforeEach: global.beforeEach,\n    describe: global.describe,\n    it: global.it\n  };\n  function modifyArguments(args, syncTest, asyncTest) {\n    for (let i = 0; i < args.length; i++) {\n      let arg = args[i];\n      if (typeof arg === 'function') {\n        // The `done` callback is only passed through if the function expects at\n        // least one argument.\n        // Note we have to make a function with correct number of arguments,\n        // otherwise mocha will\n        // think that all functions are sync or async.\n        args[i] = arg.length === 0 ? syncTest(arg) : asyncTest(arg);\n        // Mocha uses toString to view the test body in the result list, make sure we return the\n        // correct function body\n        args[i].toString = function () {\n          return arg.toString();\n        };\n      }\n    }\n    return args;\n  }\n  function wrapDescribeInZone(args) {\n    const syncTest = function (fn) {\n      return function () {\n        return syncZone.run(fn, this, arguments);\n      };\n    };\n    return modifyArguments(args, syncTest);\n  }\n  function wrapTestInZone(args) {\n    const asyncTest = function (fn) {\n      return function (done) {\n        return testZone.run(fn, this, [done]);\n      };\n    };\n    const syncTest = function (fn) {\n      return function () {\n        return testZone.run(fn, this);\n      };\n    };\n    return modifyArguments(args, syncTest, asyncTest);\n  }\n  function wrapSuiteInZone(args) {\n    const asyncTest = function (fn) {\n      return function (done) {\n        return suiteZone.run(fn, this, [done]);\n      };\n    };\n    const syncTest = function (fn) {\n      return function () {\n        return suiteZone.run(fn, this);\n      };\n    };\n    return modifyArguments(args, syncTest, asyncTest);\n  }\n  global.describe = global.suite = function () {\n    return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n  };\n  global.xdescribe = global.suite.skip = global.describe.skip = function () {\n    return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n  };\n  global.describe.only = global.suite.only = function () {\n    return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n  };\n  global.it = global.specify = global.test = function () {\n    return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n  };\n  global.xit = global.xspecify = global.it.skip = function () {\n    return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n  };\n  global.it.only = global.test.only = function () {\n    return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n  };\n  global.after = global.suiteTeardown = function () {\n    return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n  };\n  global.afterEach = global.teardown = function () {\n    return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n  };\n  global.before = global.suiteSetup = function () {\n    return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n  };\n  global.beforeEach = global.setup = function () {\n    return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n  };\n  ((originalRunTest, originalRun) => {\n    Mocha.Runner.prototype.runTest = function (fn) {\n      Zone.current.scheduleMicroTask('mocha.forceTask', () => {\n        originalRunTest.call(this, fn);\n      });\n    };\n    Mocha.Runner.prototype.run = function (fn) {\n      this.on('test', e => {\n        testZone = rootZone.fork(new ProxyZoneSpec());\n      });\n      this.on('fail', (test, err) => {\n        const proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n        if (proxyZoneSpec && err) {\n          try {\n            // try catch here in case err.message is not writable\n            err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n          } catch (error) {}\n        }\n      });\n      return originalRun.call(this, fn);\n    };\n  })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n});\n(function (_global) {\n  class AsyncTestZoneSpec {\n    static #_ = this.symbolParentUnresolved = Zone.__symbol__('parentUnresolved');\n    constructor(finishCallback, failCallback, namePrefix) {\n      this.finishCallback = finishCallback;\n      this.failCallback = failCallback;\n      this._pendingMicroTasks = false;\n      this._pendingMacroTasks = false;\n      this._alreadyErrored = false;\n      this._isSync = false;\n      this._existingFinishTimer = null;\n      this.entryFunction = null;\n      this.runZone = Zone.current;\n      this.unresolvedChainedPromiseCount = 0;\n      this.supportWaitUnresolvedChainedPromise = false;\n      this.name = 'asyncTestZone for ' + namePrefix;\n      this.properties = {\n        'AsyncTestZoneSpec': this\n      };\n      this.supportWaitUnresolvedChainedPromise = _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n    }\n    isUnresolvedChainedPromisePending() {\n      return this.unresolvedChainedPromiseCount > 0;\n    }\n    _finishCallbackIfDone() {\n      // NOTE: Technically the `onHasTask` could fire together with the initial synchronous\n      // completion in `onInvoke`. `onHasTask` might call this method when it captured e.g.\n      // microtasks in the proxy zone that now complete as part of this async zone run.\n      // Consider the following scenario:\n      //    1. A test `beforeEach` schedules a microtask in the ProxyZone.\n      //    2. An actual empty `it` spec executes in the AsyncTestZone` (using e.g. `waitForAsync`).\n      //    3. The `onInvoke` invokes `_finishCallbackIfDone` because the spec runs synchronously.\n      //    4. We wait the scheduled timeout (see below) to account for unhandled promises.\n      //    5. The microtask from (1) finishes and `onHasTask` is invoked.\n      //    --> We register a second `_finishCallbackIfDone` even though we have scheduled a timeout.\n      // If the finish timeout from below is already scheduled, terminate the existing scheduled\n      // finish invocation, avoiding calling `jasmine` `done` multiple times. *Note* that we would\n      // want to schedule a new finish callback in case the task state changes again.\n      if (this._existingFinishTimer !== null) {\n        clearTimeout(this._existingFinishTimer);\n        this._existingFinishTimer = null;\n      }\n      if (!(this._pendingMicroTasks || this._pendingMacroTasks || this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending())) {\n        // We wait until the next tick because we would like to catch unhandled promises which could\n        // cause test logic to be executed. In such cases we cannot finish with tasks pending then.\n        this.runZone.run(() => {\n          this._existingFinishTimer = setTimeout(() => {\n            if (!this._alreadyErrored && !(this._pendingMicroTasks || this._pendingMacroTasks)) {\n              this.finishCallback();\n            }\n          }, 0);\n        });\n      }\n    }\n    patchPromiseForTest() {\n      if (!this.supportWaitUnresolvedChainedPromise) {\n        return;\n      }\n      const patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n      if (patchPromiseForTest) {\n        patchPromiseForTest();\n      }\n    }\n    unPatchPromiseForTest() {\n      if (!this.supportWaitUnresolvedChainedPromise) {\n        return;\n      }\n      const unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n      if (unPatchPromiseForTest) {\n        unPatchPromiseForTest();\n      }\n    }\n    onScheduleTask(delegate, current, target, task) {\n      if (task.type !== 'eventTask') {\n        this._isSync = false;\n      }\n      if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n        // check whether the promise is a chained promise\n        if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n          // chained promise is being scheduled\n          this.unresolvedChainedPromiseCount--;\n        }\n      }\n      return delegate.scheduleTask(target, task);\n    }\n    onInvokeTask(delegate, current, target, task, applyThis, applyArgs) {\n      if (task.type !== 'eventTask') {\n        this._isSync = false;\n      }\n      return delegate.invokeTask(target, task, applyThis, applyArgs);\n    }\n    onCancelTask(delegate, current, target, task) {\n      if (task.type !== 'eventTask') {\n        this._isSync = false;\n      }\n      return delegate.cancelTask(target, task);\n    }\n    // Note - we need to use onInvoke at the moment to call finish when a test is\n    // fully synchronous. TODO(juliemr): remove this when the logic for\n    // onHasTask changes and it calls whenever the task queues are dirty.\n    // updated by(JiaLiPassion), only call finish callback when no task\n    // was scheduled/invoked/canceled.\n    onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n      if (!this.entryFunction) {\n        this.entryFunction = delegate;\n      }\n      try {\n        this._isSync = true;\n        return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n      } finally {\n        // We need to check the delegate is the same as entryFunction or not.\n        // Consider the following case.\n        //\n        // asyncTestZone.run(() => { // Here the delegate will be the entryFunction\n        //   Zone.current.run(() => { // Here the delegate will not be the entryFunction\n        //   });\n        // });\n        //\n        // We only want to check whether there are async tasks scheduled\n        // for the entry function.\n        if (this._isSync && this.entryFunction === delegate) {\n          this._finishCallbackIfDone();\n        }\n      }\n    }\n    onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n      // Let the parent try to handle the error.\n      const result = parentZoneDelegate.handleError(targetZone, error);\n      if (result) {\n        this.failCallback(error);\n        this._alreadyErrored = true;\n      }\n      return false;\n    }\n    onHasTask(delegate, current, target, hasTaskState) {\n      delegate.hasTask(target, hasTaskState);\n      // We should only trigger finishCallback when the target zone is the AsyncTestZone\n      // Consider the following cases.\n      //\n      // const childZone = asyncTestZone.fork({\n      //   name: 'child',\n      //   onHasTask: ...\n      // });\n      //\n      // So we have nested zones declared the onHasTask hook, in this case,\n      // the onHasTask will be triggered twice, and cause the finishCallbackIfDone()\n      // is also be invoked twice. So we need to only trigger the finishCallbackIfDone()\n      // when the current zone is the same as the target zone.\n      if (current !== target) {\n        return;\n      }\n      if (hasTaskState.change == 'microTask') {\n        this._pendingMicroTasks = hasTaskState.microTask;\n        this._finishCallbackIfDone();\n      } else if (hasTaskState.change == 'macroTask') {\n        this._pendingMacroTasks = hasTaskState.macroTask;\n        this._finishCallbackIfDone();\n      }\n    }\n  }\n  // Export the class so that new instances can be created with proper\n  // constructor params.\n  Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n})(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\nZone.__load_patch('asynctest', (global, Zone, api) => {\n  /**\n   * Wraps a test function in an asynchronous test zone. The test will automatically\n   * complete when all asynchronous calls within this zone are done.\n   */\n  Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n    // If we're running using the Jasmine test framework, adapt to call the 'done'\n    // function when asynchronous activity is finished.\n    if (global.jasmine) {\n      // Not using an arrow function to preserve context passed from call site\n      return function (done) {\n        if (!done) {\n          // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n          // fake it here and assume sync.\n          done = function () {};\n          done.fail = function (e) {\n            throw e;\n          };\n        }\n        runInTestZone(fn, this, done, err => {\n          if (typeof err === 'string') {\n            return done.fail(new Error(err));\n          } else {\n            done.fail(err);\n          }\n        });\n      };\n    }\n    // Otherwise, return a promise which will resolve when asynchronous activity\n    // is finished. This will be correctly consumed by the Mocha framework with\n    // it('...', async(myFn)); or can be used in a custom framework.\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n      return new Promise((finishCallback, failCallback) => {\n        runInTestZone(fn, this, finishCallback, failCallback);\n      });\n    };\n  };\n  function runInTestZone(fn, context, finishCallback, failCallback) {\n    const currentZone = Zone.current;\n    const AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n    if (AsyncTestZoneSpec === undefined) {\n      throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/async-test');\n    }\n    const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    if (!ProxyZoneSpec) {\n      throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/proxy');\n    }\n    const proxyZoneSpec = ProxyZoneSpec.get();\n    ProxyZoneSpec.assertPresent();\n    // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n    // If we do it in ProxyZone then we will get to infinite recursion.\n    const proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n    const previousDelegate = proxyZoneSpec.getDelegate();\n    proxyZone.parent.run(() => {\n      const testZoneSpec = new AsyncTestZoneSpec(() => {\n        // Need to restore the original zone.\n        if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n          // Only reset the zone spec if it's\n          // still this one. Otherwise, assume\n          // it's OK.\n          proxyZoneSpec.setDelegate(previousDelegate);\n        }\n        testZoneSpec.unPatchPromiseForTest();\n        currentZone.run(() => {\n          finishCallback();\n        });\n      }, error => {\n        // Need to restore the original zone.\n        if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n          // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n          proxyZoneSpec.setDelegate(previousDelegate);\n        }\n        testZoneSpec.unPatchPromiseForTest();\n        currentZone.run(() => {\n          failCallback(error);\n        });\n      }, 'test');\n      proxyZoneSpec.setDelegate(testZoneSpec);\n      testZoneSpec.patchPromiseForTest();\n    });\n    return Zone.current.runGuarded(fn, context);\n  }\n});\n(function (global) {\n  const OriginalDate = global.Date;\n  // Since when we compile this file to `es2015`, and if we define\n  // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n  // there will be an error which is `Cannot assign to read only property 'prototype'`\n  // so we need to use function implementation here.\n  function FakeDate() {\n    if (arguments.length === 0) {\n      const d = new OriginalDate();\n      d.setTime(FakeDate.now());\n      return d;\n    } else {\n      const args = Array.prototype.slice.call(arguments);\n      return new OriginalDate(...args);\n    }\n  }\n  FakeDate.now = function () {\n    const fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n    if (fakeAsyncTestZoneSpec) {\n      return fakeAsyncTestZoneSpec.getFakeSystemTime();\n    }\n    return OriginalDate.now.apply(this, arguments);\n  };\n  FakeDate.UTC = OriginalDate.UTC;\n  FakeDate.parse = OriginalDate.parse;\n  // keep a reference for zone patched timer function\n  const timers = {\n    setTimeout: global.setTimeout,\n    setInterval: global.setInterval,\n    clearTimeout: global.clearTimeout,\n    clearInterval: global.clearInterval\n  };\n  let Scheduler = /*#__PURE__*/(() => {\n    class Scheduler {\n      // Next scheduler id.\n      static #_ = this.nextId = 1;\n      constructor() {\n        // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n        this._schedulerQueue = [];\n        // Current simulated time in millis.\n        this._currentTickTime = 0;\n        // Current fake system base time in millis.\n        this._currentFakeBaseSystemTime = OriginalDate.now();\n        // track requeuePeriodicTimer\n        this._currentTickRequeuePeriodicEntries = [];\n      }\n      getCurrentTickTime() {\n        return this._currentTickTime;\n      }\n      getFakeSystemTime() {\n        return this._currentFakeBaseSystemTime + this._currentTickTime;\n      }\n      setFakeBaseSystemTime(fakeBaseSystemTime) {\n        this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n      }\n      getRealSystemTime() {\n        return OriginalDate.now();\n      }\n      scheduleFunction(cb, delay, options) {\n        options = {\n          ...{\n            args: [],\n            isPeriodic: false,\n            isRequestAnimationFrame: false,\n            id: -1,\n            isRequeuePeriodic: false\n          },\n          ...options\n        };\n        let currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n        let endTime = this._currentTickTime + delay;\n        // Insert so that scheduler queue remains sorted by end time.\n        let newEntry = {\n          endTime: endTime,\n          id: currentId,\n          func: cb,\n          args: options.args,\n          delay: delay,\n          isPeriodic: options.isPeriodic,\n          isRequestAnimationFrame: options.isRequestAnimationFrame\n        };\n        if (options.isRequeuePeriodic) {\n          this._currentTickRequeuePeriodicEntries.push(newEntry);\n        }\n        let i = 0;\n        for (; i < this._schedulerQueue.length; i++) {\n          let currentEntry = this._schedulerQueue[i];\n          if (newEntry.endTime < currentEntry.endTime) {\n            break;\n          }\n        }\n        this._schedulerQueue.splice(i, 0, newEntry);\n        return currentId;\n      }\n      removeScheduledFunctionWithId(id) {\n        for (let i = 0; i < this._schedulerQueue.length; i++) {\n          if (this._schedulerQueue[i].id == id) {\n            this._schedulerQueue.splice(i, 1);\n            break;\n          }\n        }\n      }\n      removeAll() {\n        this._schedulerQueue = [];\n      }\n      getTimerCount() {\n        return this._schedulerQueue.length;\n      }\n      tickToNext(step = 1, doTick, tickOptions) {\n        if (this._schedulerQueue.length < step) {\n          return;\n        }\n        // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n        const startTime = this._currentTickTime;\n        const targetTask = this._schedulerQueue[step - 1];\n        this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n      }\n      tick(millis = 0, doTick, tickOptions) {\n        let finalTime = this._currentTickTime + millis;\n        let lastCurrentTime = 0;\n        tickOptions = Object.assign({\n          processNewMacroTasksSynchronously: true\n        }, tickOptions);\n        // we need to copy the schedulerQueue so nested timeout\n        // will not be wrongly called in the current tick\n        // https://github.com/angular/angular/issues/33799\n        const schedulerQueue = tickOptions.processNewMacroTasksSynchronously ? this._schedulerQueue : this._schedulerQueue.slice();\n        if (schedulerQueue.length === 0 && doTick) {\n          doTick(millis);\n          return;\n        }\n        while (schedulerQueue.length > 0) {\n          // clear requeueEntries before each loop\n          this._currentTickRequeuePeriodicEntries = [];\n          let current = schedulerQueue[0];\n          if (finalTime < current.endTime) {\n            // Done processing the queue since it's sorted by endTime.\n            break;\n          } else {\n            // Time to run scheduled function. Remove it from the head of queue.\n            let current = schedulerQueue.shift();\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              const idx = this._schedulerQueue.indexOf(current);\n              if (idx >= 0) {\n                this._schedulerQueue.splice(idx, 1);\n              }\n            }\n            lastCurrentTime = this._currentTickTime;\n            this._currentTickTime = current.endTime;\n            if (doTick) {\n              doTick(this._currentTickTime - lastCurrentTime);\n            }\n            let retval = current.func.apply(global, current.isRequestAnimationFrame ? [this._currentTickTime] : current.args);\n            if (!retval) {\n              // Uncaught exception in the current scheduled function. Stop processing the queue.\n              break;\n            }\n            // check is there any requeue periodic entry is added in\n            // current loop, if there is, we need to add to current loop\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              this._currentTickRequeuePeriodicEntries.forEach(newEntry => {\n                let i = 0;\n                for (; i < schedulerQueue.length; i++) {\n                  const currentEntry = schedulerQueue[i];\n                  if (newEntry.endTime < currentEntry.endTime) {\n                    break;\n                  }\n                }\n                schedulerQueue.splice(i, 0, newEntry);\n              });\n            }\n          }\n        }\n        lastCurrentTime = this._currentTickTime;\n        this._currentTickTime = finalTime;\n        if (doTick) {\n          doTick(this._currentTickTime - lastCurrentTime);\n        }\n      }\n      flushOnlyPendingTimers(doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        }\n        // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n        const startTime = this._currentTickTime;\n        const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick, {\n          processNewMacroTasksSynchronously: false\n        });\n        return this._currentTickTime - startTime;\n      }\n      flush(limit = 20, flushPeriodic = false, doTick) {\n        if (flushPeriodic) {\n          return this.flushPeriodic(doTick);\n        } else {\n          return this.flushNonPeriodic(limit, doTick);\n        }\n      }\n      flushPeriodic(doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        }\n        // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n        const startTime = this._currentTickTime;\n        const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick);\n        return this._currentTickTime - startTime;\n      }\n      flushNonPeriodic(limit, doTick) {\n        const startTime = this._currentTickTime;\n        let lastCurrentTime = 0;\n        let count = 0;\n        while (this._schedulerQueue.length > 0) {\n          count++;\n          if (count > limit) {\n            throw new Error('flush failed after reaching the limit of ' + limit + ' tasks. Does your code use a polling timeout?');\n          }\n          // flush only non-periodic timers.\n          // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n          if (this._schedulerQueue.filter(task => !task.isPeriodic && !task.isRequestAnimationFrame).length === 0) {\n            break;\n          }\n          const current = this._schedulerQueue.shift();\n          lastCurrentTime = this._currentTickTime;\n          this._currentTickTime = current.endTime;\n          if (doTick) {\n            // Update any secondary schedulers like Jasmine mock Date.\n            doTick(this._currentTickTime - lastCurrentTime);\n          }\n          const retval = current.func.apply(global, current.args);\n          if (!retval) {\n            // Uncaught exception in the current scheduled function. Stop processing the queue.\n            break;\n          }\n        }\n        return this._currentTickTime - startTime;\n      }\n    }\n    return Scheduler;\n  })();\n  class FakeAsyncTestZoneSpec {\n    static assertInZone() {\n      if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n        throw new Error('The code should be running in the fakeAsync zone to call this function');\n      }\n    }\n    constructor(namePrefix, trackPendingRequestAnimationFrame = false, macroTaskOptions) {\n      this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n      this.macroTaskOptions = macroTaskOptions;\n      this._scheduler = new Scheduler();\n      this._microtasks = [];\n      this._lastError = null;\n      this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n      this.pendingPeriodicTimers = [];\n      this.pendingTimers = [];\n      this.patchDateLocked = false;\n      this.properties = {\n        'FakeAsyncTestZoneSpec': this\n      };\n      this.name = 'fakeAsyncTestZone for ' + namePrefix;\n      // in case user can't access the construction of FakeAsyncTestSpec\n      // user can also define macroTaskOptions by define a global variable.\n      if (!this.macroTaskOptions) {\n        this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n      }\n    }\n    _fnAndFlush(fn, completers) {\n      return (...args) => {\n        fn.apply(global, args);\n        if (this._lastError === null) {\n          // Success\n          if (completers.onSuccess != null) {\n            completers.onSuccess.apply(global);\n          }\n          // Flush microtasks only on success.\n          this.flushMicrotasks();\n        } else {\n          // Failure\n          if (completers.onError != null) {\n            completers.onError.apply(global);\n          }\n        }\n        // Return true if there were no errors, false otherwise.\n        return this._lastError === null;\n      };\n    }\n    static _removeTimer(timers, id) {\n      let index = timers.indexOf(id);\n      if (index > -1) {\n        timers.splice(index, 1);\n      }\n    }\n    _dequeueTimer(id) {\n      return () => {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n      };\n    }\n    _requeuePeriodicTimer(fn, interval, args, id) {\n      return () => {\n        // Requeue the timer callback if it's not been canceled.\n        if (this.pendingPeriodicTimers.indexOf(id) !== -1) {\n          this._scheduler.scheduleFunction(fn, interval, {\n            args,\n            isPeriodic: true,\n            id,\n            isRequeuePeriodic: true\n          });\n        }\n      };\n    }\n    _dequeuePeriodicTimer(id) {\n      return () => {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n      };\n    }\n    _setTimeout(fn, delay, args, isTimer = true) {\n      let removeTimerFn = this._dequeueTimer(Scheduler.nextId);\n      // Queue the callback and dequeue the timer on success and error.\n      let cb = this._fnAndFlush(fn, {\n        onSuccess: removeTimerFn,\n        onError: removeTimerFn\n      });\n      let id = this._scheduler.scheduleFunction(cb, delay, {\n        args,\n        isRequestAnimationFrame: !isTimer\n      });\n      if (isTimer) {\n        this.pendingTimers.push(id);\n      }\n      return id;\n    }\n    _clearTimeout(id) {\n      FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n      this._scheduler.removeScheduledFunctionWithId(id);\n    }\n    _setInterval(fn, interval, args) {\n      let id = Scheduler.nextId;\n      let completers = {\n        onSuccess: null,\n        onError: this._dequeuePeriodicTimer(id)\n      };\n      let cb = this._fnAndFlush(fn, completers);\n      // Use the callback created above to requeue on success.\n      completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);\n      // Queue the callback and dequeue the periodic timer only on error.\n      this._scheduler.scheduleFunction(cb, interval, {\n        args,\n        isPeriodic: true\n      });\n      this.pendingPeriodicTimers.push(id);\n      return id;\n    }\n    _clearInterval(id) {\n      FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n      this._scheduler.removeScheduledFunctionWithId(id);\n    }\n    _resetLastErrorAndThrow() {\n      let error = this._lastError || this._uncaughtPromiseErrors[0];\n      this._uncaughtPromiseErrors.length = 0;\n      this._lastError = null;\n      throw error;\n    }\n    getCurrentTickTime() {\n      return this._scheduler.getCurrentTickTime();\n    }\n    getFakeSystemTime() {\n      return this._scheduler.getFakeSystemTime();\n    }\n    setFakeBaseSystemTime(realTime) {\n      this._scheduler.setFakeBaseSystemTime(realTime);\n    }\n    getRealSystemTime() {\n      return this._scheduler.getRealSystemTime();\n    }\n    static patchDate() {\n      if (!!global[Zone.__symbol__('disableDatePatching')]) {\n        // we don't want to patch global Date\n        // because in some case, global Date\n        // is already being patched, we need to provide\n        // an option to let user still use their\n        // own version of Date.\n        return;\n      }\n      if (global['Date'] === FakeDate) {\n        // already patched\n        return;\n      }\n      global['Date'] = FakeDate;\n      FakeDate.prototype = OriginalDate.prototype;\n      // try check and reset timers\n      // because jasmine.clock().install() may\n      // have replaced the global timer\n      FakeAsyncTestZoneSpec.checkTimerPatch();\n    }\n    static resetDate() {\n      if (global['Date'] === FakeDate) {\n        global['Date'] = OriginalDate;\n      }\n    }\n    static checkTimerPatch() {\n      if (global.setTimeout !== timers.setTimeout) {\n        global.setTimeout = timers.setTimeout;\n        global.clearTimeout = timers.clearTimeout;\n      }\n      if (global.setInterval !== timers.setInterval) {\n        global.setInterval = timers.setInterval;\n        global.clearInterval = timers.clearInterval;\n      }\n    }\n    lockDatePatch() {\n      this.patchDateLocked = true;\n      FakeAsyncTestZoneSpec.patchDate();\n    }\n    unlockDatePatch() {\n      this.patchDateLocked = false;\n      FakeAsyncTestZoneSpec.resetDate();\n    }\n    tickToNext(steps = 1, doTick, tickOptions = {\n      processNewMacroTasksSynchronously: true\n    }) {\n      if (steps <= 0) {\n        return;\n      }\n      FakeAsyncTestZoneSpec.assertInZone();\n      this.flushMicrotasks();\n      this._scheduler.tickToNext(steps, doTick, tickOptions);\n      if (this._lastError !== null) {\n        this._resetLastErrorAndThrow();\n      }\n    }\n    tick(millis = 0, doTick, tickOptions = {\n      processNewMacroTasksSynchronously: true\n    }) {\n      FakeAsyncTestZoneSpec.assertInZone();\n      this.flushMicrotasks();\n      this._scheduler.tick(millis, doTick, tickOptions);\n      if (this._lastError !== null) {\n        this._resetLastErrorAndThrow();\n      }\n    }\n    flushMicrotasks() {\n      FakeAsyncTestZoneSpec.assertInZone();\n      const flushErrors = () => {\n        if (this._lastError !== null || this._uncaughtPromiseErrors.length) {\n          // If there is an error stop processing the microtask queue and rethrow the error.\n          this._resetLastErrorAndThrow();\n        }\n      };\n      while (this._microtasks.length > 0) {\n        let microtask = this._microtasks.shift();\n        microtask.func.apply(microtask.target, microtask.args);\n      }\n      flushErrors();\n    }\n    flush(limit, flushPeriodic, doTick) {\n      FakeAsyncTestZoneSpec.assertInZone();\n      this.flushMicrotasks();\n      const elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n      if (this._lastError !== null) {\n        this._resetLastErrorAndThrow();\n      }\n      return elapsed;\n    }\n    flushOnlyPendingTimers(doTick) {\n      FakeAsyncTestZoneSpec.assertInZone();\n      this.flushMicrotasks();\n      const elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n      if (this._lastError !== null) {\n        this._resetLastErrorAndThrow();\n      }\n      return elapsed;\n    }\n    removeAllTimers() {\n      FakeAsyncTestZoneSpec.assertInZone();\n      this._scheduler.removeAll();\n      this.pendingPeriodicTimers = [];\n      this.pendingTimers = [];\n    }\n    getTimerCount() {\n      return this._scheduler.getTimerCount() + this._microtasks.length;\n    }\n    onScheduleTask(delegate, current, target, task) {\n      switch (task.type) {\n        case 'microTask':\n          let args = task.data && task.data.args;\n          // should pass additional arguments to callback if have any\n          // currently we know process.nextTick will have such additional\n          // arguments\n          let additionalArgs;\n          if (args) {\n            let callbackIndex = task.data.cbIdx;\n            if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n              additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n            }\n          }\n          this._microtasks.push({\n            func: task.invoke,\n            args: additionalArgs,\n            target: task.data && task.data.target\n          });\n          break;\n        case 'macroTask':\n          switch (task.source) {\n            case 'setTimeout':\n              task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n              break;\n            case 'setImmediate':\n              task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n              break;\n            case 'setInterval':\n              task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n              break;\n            case 'XMLHttpRequest.send':\n              throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' + task.data['url']);\n            case 'requestAnimationFrame':\n            case 'webkitRequestAnimationFrame':\n            case 'mozRequestAnimationFrame':\n              // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n              // (60 frames per second)\n              task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n              break;\n            default:\n              // user can define which macroTask they want to support by passing\n              // macroTaskOptions\n              const macroTaskOption = this.findMacroTaskOption(task);\n              if (macroTaskOption) {\n                const args = task.data && task.data['args'];\n                const delay = args && args.length > 1 ? args[1] : 0;\n                let callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args;\n                if (!!macroTaskOption.isPeriodic) {\n                  // periodic macroTask, use setInterval to simulate\n                  task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                  task.data.isPeriodic = true;\n                } else {\n                  // not periodic, use setTimeout to simulate\n                  task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                }\n                break;\n              }\n              throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n          }\n          break;\n        case 'eventTask':\n          task = delegate.scheduleTask(target, task);\n          break;\n      }\n      return task;\n    }\n    onCancelTask(delegate, current, target, task) {\n      switch (task.source) {\n        case 'setTimeout':\n        case 'requestAnimationFrame':\n        case 'webkitRequestAnimationFrame':\n        case 'mozRequestAnimationFrame':\n          return this._clearTimeout(task.data['handleId']);\n        case 'setInterval':\n          return this._clearInterval(task.data['handleId']);\n        default:\n          // user can define which macroTask they want to support by passing\n          // macroTaskOptions\n          const macroTaskOption = this.findMacroTaskOption(task);\n          if (macroTaskOption) {\n            const handleId = task.data['handleId'];\n            return macroTaskOption.isPeriodic ? this._clearInterval(handleId) : this._clearTimeout(handleId);\n          }\n          return delegate.cancelTask(target, task);\n      }\n    }\n    onInvoke(delegate, current, target, callback, applyThis, applyArgs, source) {\n      try {\n        FakeAsyncTestZoneSpec.patchDate();\n        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n      } finally {\n        if (!this.patchDateLocked) {\n          FakeAsyncTestZoneSpec.resetDate();\n        }\n      }\n    }\n    findMacroTaskOption(task) {\n      if (!this.macroTaskOptions) {\n        return null;\n      }\n      for (let i = 0; i < this.macroTaskOptions.length; i++) {\n        const macroTaskOption = this.macroTaskOptions[i];\n        if (macroTaskOption.source === task.source) {\n          return macroTaskOption;\n        }\n      }\n      return null;\n    }\n    onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n      this._lastError = error;\n      return false; // Don't propagate error to parent zone.\n    }\n  }\n  // Export the class so that new instances can be created with proper\n  // constructor params.\n  Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n})(typeof window === 'object' && window || typeof self === 'object' && self || global);\nZone.__load_patch('fakeasync', (global, Zone, api) => {\n  const FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n  function getProxyZoneSpec() {\n    return Zone && Zone['ProxyZoneSpec'];\n  }\n  let _fakeAsyncTestZoneSpec = null;\n  /**\n   * Clears out the shared fake async zone for a test.\n   * To be called in a global `beforeEach`.\n   *\n   * @experimental\n   */\n  function resetFakeAsyncZone() {\n    if (_fakeAsyncTestZoneSpec) {\n      _fakeAsyncTestZoneSpec.unlockDatePatch();\n    }\n    _fakeAsyncTestZoneSpec = null;\n    // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n    getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n  }\n  /**\n   * Wraps a function to be executed in the fakeAsync zone:\n   * - microtasks are manually executed by calling `flushMicrotasks()`,\n   * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n   *\n   * If there are any pending timers at the end of the function, an exception will be thrown.\n   *\n   * Can be used to wrap inject() calls.\n   *\n   * ## Example\n   *\n   * {@example core/testing/ts/fake_async.ts region='basic'}\n   *\n   * @param fn\n   * @returns The function wrapped to be executed in the fakeAsync zone\n   *\n   * @experimental\n   */\n  function fakeAsync(fn) {\n    // Not using an arrow function to preserve context passed from call site\n    const fakeAsyncFn = function (...args) {\n      const ProxyZoneSpec = getProxyZoneSpec();\n      if (!ProxyZoneSpec) {\n        throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/plugins/proxy');\n      }\n      const proxyZoneSpec = ProxyZoneSpec.assertPresent();\n      if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n        throw new Error('fakeAsync() calls can not be nested');\n      }\n      try {\n        // in case jasmine.clock init a fakeAsyncTestZoneSpec\n        if (!_fakeAsyncTestZoneSpec) {\n          if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n            throw new Error('fakeAsync() calls can not be nested');\n          }\n          _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n        }\n        let res;\n        const lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n        proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n        _fakeAsyncTestZoneSpec.lockDatePatch();\n        try {\n          res = fn.apply(this, args);\n          flushMicrotasks();\n        } finally {\n          proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n        }\n        if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n          throw new Error(`${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} ` + `periodic timer(s) still in the queue.`);\n        }\n        if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n          throw new Error(`${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);\n        }\n        return res;\n      } finally {\n        resetFakeAsyncZone();\n      }\n    };\n    fakeAsyncFn.isFakeAsync = true;\n    return fakeAsyncFn;\n  }\n  function _getFakeAsyncZoneSpec() {\n    if (_fakeAsyncTestZoneSpec == null) {\n      _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n      if (_fakeAsyncTestZoneSpec == null) {\n        throw new Error('The code should be running in the fakeAsync zone to call this function');\n      }\n    }\n    return _fakeAsyncTestZoneSpec;\n  }\n  /**\n   * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n   *\n   * The microtasks queue is drained at the very start of this function and after any timer callback\n   * has been executed.\n   *\n   * ## Example\n   *\n   * {@example core/testing/ts/fake_async.ts region='basic'}\n   *\n   * @experimental\n   */\n  function tick(millis = 0, ignoreNestedTimeout = false) {\n    _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n  }\n  /**\n   * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n   * draining the macrotask queue until it is empty. The returned value is the milliseconds\n   * of time that would have been elapsed.\n   *\n   * @param maxTurns\n   * @returns The simulated time elapsed, in millis.\n   *\n   * @experimental\n   */\n  function flush(maxTurns) {\n    return _getFakeAsyncZoneSpec().flush(maxTurns);\n  }\n  /**\n   * Discard all remaining periodic tasks.\n   *\n   * @experimental\n   */\n  function discardPeriodicTasks() {\n    const zoneSpec = _getFakeAsyncZoneSpec();\n    zoneSpec.pendingPeriodicTimers;\n    zoneSpec.pendingPeriodicTimers.length = 0;\n  }\n  /**\n   * Flush any pending microtasks.\n   *\n   * @experimental\n   */\n  function flushMicrotasks() {\n    _getFakeAsyncZoneSpec().flushMicrotasks();\n  }\n  Zone[api.symbol('fakeAsyncTest')] = {\n    resetFakeAsyncZone,\n    flushMicrotasks,\n    discardPeriodicTasks,\n    tick,\n    flush,\n    fakeAsync\n  };\n}, true);\n\n/**\n * Promise for async/fakeAsync zoneSpec test\n * can support async operation which not supported by zone.js\n * such as\n * it ('test jsonp in AsyncZone', async() => {\n *   new Promise(res => {\n *     jsonp(url, (data) => {\n *       // success callback\n *       res(data);\n *     });\n *   }).then((jsonpResult) => {\n *     // get jsonp result.\n *\n *     // user will expect AsyncZoneSpec wait for\n *     // then, but because jsonp is not zone aware\n *     // AsyncZone will finish before then is called.\n *   });\n * });\n */\nZone.__load_patch('promisefortest', (global, Zone, api) => {\n  const symbolState = api.symbol('state');\n  const UNRESOLVED = null;\n  const symbolParentUnresolved = api.symbol('parentUnresolved');\n  // patch Promise.prototype.then to keep an internal\n  // number for tracking unresolved chained promise\n  // we will decrease this number when the parent promise\n  // being resolved/rejected and chained promise was\n  // scheduled as a microTask.\n  // so we can know such kind of chained promise still\n  // not resolved in AsyncTestZone\n  Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n    let oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n    if (oriThen) {\n      return;\n    }\n    oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n    Promise.prototype.then = function () {\n      const chained = oriThen.apply(this, arguments);\n      if (this[symbolState] === UNRESOLVED) {\n        // parent promise is unresolved.\n        const asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n        if (asyncTestZoneSpec) {\n          asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n          chained[symbolParentUnresolved] = true;\n        }\n      }\n      return chained;\n    };\n  };\n  Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n    // restore origin then\n    const oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n    if (oriThen) {\n      Promise.prototype.then = oriThen;\n      Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n    }\n  };\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}