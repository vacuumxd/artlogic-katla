{"ast":null,"code":"import { Component, Directive, Input, Output, EventEmitter, ChangeDetectionStrategy, Injector, Renderer2, ElementRef, ViewContainerRef, ComponentFactoryResolver, NgZone } from '@angular/core';\nimport { listenToTriggers } from '../util/triggers';\nimport { positionElements } from '../util/positioning';\nimport { PopupService } from '../util/popup';\nimport { NgbTooltipConfig } from './tooltip-config';\nvar nextId = 0;\nvar NgbTooltipWindow = /** @class */function () {\n  function NgbTooltipWindow(_element, _renderer) {\n    this._element = _element;\n    this._renderer = _renderer;\n    this.placement = 'top';\n  }\n  NgbTooltipWindow.prototype.applyPlacement = function (_placement) {\n    // remove the current placement classes\n    this._renderer.removeClass(this._element.nativeElement, 'bs-tooltip-' + this.placement.toString().split('-')[0]);\n    this._renderer.removeClass(this._element.nativeElement, 'bs-tooltip-' + this.placement.toString());\n    // set the new placement classes\n    this.placement = _placement;\n    // apply the new placement\n    this._renderer.addClass(this._element.nativeElement, 'bs-tooltip-' + this.placement.toString().split('-')[0]);\n    this._renderer.addClass(this._element.nativeElement, 'bs-tooltip-' + this.placement.toString());\n  };\n  NgbTooltipWindow.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ngb-tooltip-window',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      host: {\n        '[class]': '\"tooltip show bs-tooltip-\" + placement.split(\"-\")[0]+\" bs-tooltip-\" + placement',\n        'role': 'tooltip',\n        '[id]': 'id'\n      },\n      template: \"<div class=\\\"arrow\\\"></div><div class=\\\"tooltip-inner\\\"><ng-content></ng-content></div>\",\n      styles: [\"\\n    :host.bs-tooltip-top .arrow, :host.bs-tooltip-bottom .arrow {\\n      left: calc(50% - 0.4rem);\\n    }\\n\\n    :host.bs-tooltip-top-left .arrow, :host.bs-tooltip-bottom-left .arrow {\\n      left: 1em;\\n    }\\n\\n    :host.bs-tooltip-top-right .arrow, :host.bs-tooltip-bottom-right .arrow {\\n      left: auto;\\n      right: 0.8rem;\\n    }\\n\\n    :host.bs-tooltip-left .arrow, :host.bs-tooltip-right .arrow {\\n      top: calc(50% - 0.4rem);\\n    }\\n\\n    :host.bs-tooltip-left-top .arrow, :host.bs-tooltip-right-top .arrow {\\n      top: 0.4rem;\\n    }\\n\\n    :host.bs-tooltip-left-bottom .arrow, :host.bs-tooltip-right-bottom .arrow {\\n      top: auto;\\n      bottom: 0.4rem;\\n    }\\n  \"]\n    }]\n  }];\n  /** @nocollapse */\n  NgbTooltipWindow.ctorParameters = function () {\n    return [{\n      type: ElementRef\n    }, {\n      type: Renderer2\n    }];\n  };\n  NgbTooltipWindow.propDecorators = {\n    \"placement\": [{\n      type: Input\n    }],\n    \"id\": [{\n      type: Input\n    }]\n  };\n  return NgbTooltipWindow;\n}();\nexport { NgbTooltipWindow };\n/**\n * A lightweight, extensible directive for fancy tooltip creation.\n */\nvar NgbTooltip = /** @class */function () {\n  function NgbTooltip(_elementRef, _renderer, injector, componentFactoryResolver, viewContainerRef, config, ngZone) {\n    var _this = this;\n    this._elementRef = _elementRef;\n    this._renderer = _renderer;\n    /**\n       * Emits an event when the tooltip is shown\n       */\n    this.shown = new EventEmitter();\n    /**\n       * Emits an event when the tooltip is hidden\n       */\n    this.hidden = new EventEmitter();\n    this._ngbTooltipWindowId = \"ngb-tooltip-\" + nextId++;\n    this.placement = config.placement;\n    this.triggers = config.triggers;\n    this.container = config.container;\n    this.disableTooltip = config.disableTooltip;\n    this._popupService = new PopupService(NgbTooltipWindow, injector, viewContainerRef, _renderer, componentFactoryResolver);\n    this._zoneSubscription = ngZone.onStable.subscribe(function () {\n      if (_this._windowRef) {\n        _this._windowRef.instance.applyPlacement(positionElements(_this._elementRef.nativeElement, _this._windowRef.location.nativeElement, _this.placement, _this.container === 'body'));\n      }\n    });\n  }\n  Object.defineProperty(NgbTooltip.prototype, \"ngbTooltip\", {\n    get: function () {\n      return this._ngbTooltip;\n    },\n    set:\n    /**\n    * Content to be displayed as tooltip. If falsy, the tooltip won't open.\n    */\n    function (value) {\n      this._ngbTooltip = value;\n      if (!value && this._windowRef) {\n        this.close();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Opens an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n   * The context is an optional value to be injected into the tooltip template when it is created.\n   */\n  /**\n     * Opens an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n     * The context is an optional value to be injected into the tooltip template when it is created.\n     */\n  NgbTooltip.prototype.open =\n  /**\n  * Opens an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n  * The context is an optional value to be injected into the tooltip template when it is created.\n  */\n  function (context) {\n    if (!this._windowRef && this._ngbTooltip && !this.disableTooltip) {\n      this._windowRef = this._popupService.open(this._ngbTooltip, context);\n      this._windowRef.instance.id = this._ngbTooltipWindowId;\n      this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-describedby', this._ngbTooltipWindowId);\n      if (this.container === 'body') {\n        window.document.querySelector(this.container).appendChild(this._windowRef.location.nativeElement);\n      }\n      this._windowRef.instance.placement = Array.isArray(this.placement) ? this.placement[0] : this.placement;\n      // apply styling to set basic css-classes on target element, before going for positioning\n      this._windowRef.changeDetectorRef.detectChanges();\n      this._windowRef.changeDetectorRef.markForCheck();\n      // position tooltip along the element\n      this._windowRef.instance.applyPlacement(positionElements(this._elementRef.nativeElement, this._windowRef.location.nativeElement, this.placement, this.container === 'body'));\n      this.shown.emit();\n    }\n  };\n  /**\n   * Closes an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n   */\n  /**\n     * Closes an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n     */\n  NgbTooltip.prototype.close =\n  /**\n  * Closes an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n  */\n  function () {\n    if (this._windowRef != null) {\n      this._renderer.removeAttribute(this._elementRef.nativeElement, 'aria-describedby');\n      this._popupService.close();\n      this._windowRef = null;\n      this.hidden.emit();\n    }\n  };\n  /**\n   * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n   */\n  /**\n     * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n     */\n  NgbTooltip.prototype.toggle =\n  /**\n  * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n  */\n  function () {\n    if (this._windowRef) {\n      this.close();\n    } else {\n      this.open();\n    }\n  };\n  /**\n   * Returns whether or not the tooltip is currently being shown\n   */\n  /**\n     * Returns whether or not the tooltip is currently being shown\n     */\n  NgbTooltip.prototype.isOpen =\n  /**\n  * Returns whether or not the tooltip is currently being shown\n  */\n  function () {\n    return this._windowRef != null;\n  };\n  NgbTooltip.prototype.ngOnInit = function () {\n    this._unregisterListenersFn = listenToTriggers(this._renderer, this._elementRef.nativeElement, this.triggers, this.open.bind(this), this.close.bind(this), this.toggle.bind(this));\n  };\n  NgbTooltip.prototype.ngOnDestroy = function () {\n    this.close();\n    // This check is needed as it might happen that ngOnDestroy is called before ngOnInit\n    // under certain conditions, see: https://github.com/ng-bootstrap/ng-bootstrap/issues/2199\n    if (this._unregisterListenersFn) {\n      this._unregisterListenersFn();\n    }\n    this._zoneSubscription.unsubscribe();\n  };\n  NgbTooltip.decorators = [{\n    type: Directive,\n    args: [{\n      selector: '[ngbTooltip]',\n      exportAs: 'ngbTooltip'\n    }]\n  }];\n  /** @nocollapse */\n  NgbTooltip.ctorParameters = function () {\n    return [{\n      type: ElementRef\n    }, {\n      type: Renderer2\n    }, {\n      type: Injector\n    }, {\n      type: ComponentFactoryResolver\n    }, {\n      type: ViewContainerRef\n    }, {\n      type: NgbTooltipConfig\n    }, {\n      type: NgZone\n    }];\n  };\n  NgbTooltip.propDecorators = {\n    \"placement\": [{\n      type: Input\n    }],\n    \"triggers\": [{\n      type: Input\n    }],\n    \"container\": [{\n      type: Input\n    }],\n    \"disableTooltip\": [{\n      type: Input\n    }],\n    \"shown\": [{\n      type: Output\n    }],\n    \"hidden\": [{\n      type: Output\n    }],\n    \"ngbTooltip\": [{\n      type: Input\n    }]\n  };\n  return NgbTooltip;\n}();\nexport { NgbTooltip };\n//# sourceMappingURL=tooltip.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}