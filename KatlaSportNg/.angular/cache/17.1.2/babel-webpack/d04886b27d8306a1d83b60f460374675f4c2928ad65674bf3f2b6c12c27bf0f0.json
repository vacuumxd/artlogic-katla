{"ast":null,"code":"import { DOCUMENT } from '@angular/common';\nimport { Inject, Injectable, NgZone } from '@angular/core';\nvar FOCUSABLE_ELEMENTS_SELECTOR = ['a[href]', 'button:not([disabled])', 'input:not([disabled]):not([type=\"hidden\"])', 'select:not([disabled])', 'textarea:not([disabled])', '[contenteditable]', '[tabindex]:not([tabindex=\"-1\"])'].join(', ');\nvar DIRECTION = /*#__PURE__*/function (DIRECTION) {\n  DIRECTION[DIRECTION[\"BACKWARD\"] = 0] = \"BACKWARD\";\n  DIRECTION[DIRECTION[\"FORWARD\"] = 1] = \"FORWARD\";\n  return DIRECTION;\n}(DIRECTION || {});\n/**\n * Class that enforce the browser focus to be trapped inside a DOM element.\n *\n * The implementation is rather simple, the class add a `focusin` listener on the document with capture phase.\n * Any focus event will then be caught, and therefore the class will only allow the one for elements contained inside\n * it's own element.\n *\n * In case the element is not contained, the class will determine which new element has to be focused based on the `tab`\n * navigation direction.\n *\n * Should not be used directly. Use only via {@link NgbFocusTrapFactory}\n */\nvar\n/**\n* Class that enforce the browser focus to be trapped inside a DOM element.\n*\n* The implementation is rather simple, the class add a `focusin` listener on the document with capture phase.\n* Any focus event will then be caught, and therefore the class will only allow the one for elements contained inside\n* it's own element.\n*\n* In case the element is not contained, the class will determine which new element has to be focused based on the `tab`\n* navigation direction.\n*\n* Should not be used directly. Use only via {@link NgbFocusTrapFactory}\n*/\nNgbFocusTrap = /** @class */function () {\n  /**\n   * @param _element The element around which focus will be trapped inside\n   * @param autofocus Initially put the focus on specific element with a `ngbFocustrap` attribute. Will also remenber\n   * and restore any previously focused element on destroy.\n   * @param _document Document on which `focusin` and `keydown.TAB` events are listened\n   * @param _ngZone The zone Angular is running in\n   */\n  function NgbFocusTrap(_element, autofocus, _document, _ngZone) {\n    var _this = this;\n    this._element = _element;\n    this._document = _document;\n    this._ngZone = _ngZone;\n    this._direction = DIRECTION.FORWARD;\n    this._previouslyFocused = null;\n    this._endOfDocument = null;\n    this._enforceFocus = this._enforceFocus.bind(this);\n    this._detectDirection = this._detectDirection.bind(this);\n    var eod = this._endOfDocument = this._document.createElement('i');\n    eod.className = 'ngb-focustrap-eod';\n    eod.tabIndex = 0;\n    this._document.body.appendChild(eod);\n    this._ngZone.runOutsideAngular(function () {\n      _this._document.addEventListener('focusin', _this._enforceFocus, true);\n      _this._document.addEventListener('keydown', _this._detectDirection);\n      _this._removeDocumentListener = function () {\n        _this._document.removeEventListener('focusin', _this._enforceFocus, true);\n        _this._document.removeEventListener('keydown', _this._detectDirection);\n      };\n    });\n    if (autofocus === true) {\n      this._previouslyFocused = document.activeElement;\n      this._focusInitial();\n    }\n  }\n  Object.defineProperty(NgbFocusTrap.prototype, \"focusableElement\", {\n    /**\n     * Guess the next focusable element.\n     * Computation is based on specific CSS selector and [tab] navigation direction\n     */\n    get:\n    /**\n    * Guess the next focusable element.\n    * Computation is based on specific CSS selector and [tab] navigation direction\n    */\n    function () {\n      var list = this._element.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR);\n      return this._direction === DIRECTION.BACKWARD ? list[list.length - 1] : list[0];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** Detect if incoming focus event should be prevented or not */\n  /** Detect if incoming focus event should be prevented or not */\n  NgbFocusTrap.prototype._enforceFocus = /** Detect if incoming focus event should be prevented or not */\n  function (event) {\n    var _this = this;\n    var target = event.target;\n    if (this._document !== target && this._element !== target && !this._element.contains(target)) {\n      this._ngZone.run(function () {\n        var element = _this.focusableElement;\n        if (element) {\n          element.focus();\n          event.stopPropagation();\n        }\n      });\n    }\n  };\n  /** Event handler detecting current `tab` navigation direction */\n  /** Event handler detecting current `tab` navigation direction */\n  NgbFocusTrap.prototype._detectDirection = /** Event handler detecting current `tab` navigation direction */\n  function (event) {\n    var shiftKey = event.shiftKey,\n      key = event.key;\n    if (key === 'Tab') {\n      this._direction = shiftKey ? DIRECTION.BACKWARD : DIRECTION.FORWARD;\n    }\n  };\n  /** Try to set focus on the first found element that has an ngbAutofocus attribute */\n  /** Try to set focus on the first found element that has an ngbAutofocus attribute */\n  NgbFocusTrap.prototype._focusInitial = /** Try to set focus on the first found element that has an ngbAutofocus attribute */\n  function () {\n    var element = this._element.querySelector('[ngbAutofocus]');\n    if (element) {\n      element.focus();\n    }\n  };\n  /**\n   * Destroys the focustrap by removing all event listeners set on document.\n   *\n   * Eventually put the focus back on the previously focused element at the time\n   * focustrap has been initialized.\n   */\n  /**\n     * Destroys the focustrap by removing all event listeners set on document.\n     *\n     * Eventually put the focus back on the previously focused element at the time\n     * focustrap has been initialized.\n     */\n  NgbFocusTrap.prototype.destroy =\n  /**\n  * Destroys the focustrap by removing all event listeners set on document.\n  *\n  * Eventually put the focus back on the previously focused element at the time\n  * focustrap has been initialized.\n  */\n  function () {\n    this._removeDocumentListener();\n    this._document.body.removeChild(this._endOfDocument);\n    if (this._previouslyFocused) {\n      this._previouslyFocused.focus();\n    }\n  };\n  return NgbFocusTrap;\n}();\n/**\n * Class that enforce the browser focus to be trapped inside a DOM element.\n *\n * The implementation is rather simple, the class add a `focusin` listener on the document with capture phase.\n * Any focus event will then be caught, and therefore the class will only allow the one for elements contained inside\n * it's own element.\n *\n * In case the element is not contained, the class will determine which new element has to be focused based on the `tab`\n * navigation direction.\n *\n * Should not be used directly. Use only via {@link NgbFocusTrapFactory}\n */\nexport { NgbFocusTrap };\n/**\n * Factory service to easily create a `NgbFocusTrap` instance on an element\n */\nvar NgbFocusTrapFactory = /** @class */function () {\n  function NgbFocusTrapFactory(_document, _ngZone) {\n    this._document = _document;\n    this._ngZone = _ngZone;\n  }\n  /**\n   * Create an instance of {@link NgbFocusTrap} and return it\n   * @param element HTMLElement to trap focus inside\n   * @param autofocus Whether the focustrap should automatically move focus into the trapped element upon\n   * initialization and return focus to the previous activeElement upon destruction.\n   */\n  /**\n     * Create an instance of {@link NgbFocusTrap} and return it\n     * @param element HTMLElement to trap focus inside\n     * @param autofocus Whether the focustrap should automatically move focus into the trapped element upon\n     * initialization and return focus to the previous activeElement upon destruction.\n     */\n  NgbFocusTrapFactory.prototype.create =\n  /**\n  * Create an instance of {@link NgbFocusTrap} and return it\n  * @param element HTMLElement to trap focus inside\n  * @param autofocus Whether the focustrap should automatically move focus into the trapped element upon\n  * initialization and return focus to the previous activeElement upon destruction.\n  */\n  function (element, autofocus) {\n    if (autofocus === void 0) {\n      autofocus = false;\n    }\n    return new NgbFocusTrap(element, autofocus, this._document, this._ngZone);\n  };\n  NgbFocusTrapFactory.decorators = [{\n    type: Injectable\n  }];\n  /** @nocollapse */\n  NgbFocusTrapFactory.ctorParameters = function () {\n    return [{\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: NgZone\n    }];\n  };\n  return NgbFocusTrapFactory;\n}();\nexport { NgbFocusTrapFactory };\n//# sourceMappingURL=focus-trap.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}