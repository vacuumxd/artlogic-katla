{"ast":null,"code":"import { Component, Directive, Input, Output, EventEmitter, ChangeDetectionStrategy, Injector, Renderer2, ElementRef, ViewContainerRef, ComponentFactoryResolver, NgZone } from '@angular/core';\nimport { listenToTriggers } from '../util/triggers';\nimport { positionElements } from '../util/positioning';\nimport { PopupService } from '../util/popup';\nimport { NgbPopoverConfig } from './popover-config';\nvar nextId = 0;\nvar NgbPopoverWindow = /** @class */function () {\n  function NgbPopoverWindow(_element, _renderer) {\n    this._element = _element;\n    this._renderer = _renderer;\n    this.placement = 'top';\n  }\n  NgbPopoverWindow.prototype.applyPlacement = function (_placement) {\n    // remove the current placement classes\n    this._renderer.removeClass(this._element.nativeElement, 'bs-popover-' + this.placement.toString().split('-')[0]);\n    this._renderer.removeClass(this._element.nativeElement, 'bs-popover-' + this.placement.toString());\n    // set the new placement classes\n    this.placement = _placement;\n    // apply the new placement\n    this._renderer.addClass(this._element.nativeElement, 'bs-popover-' + this.placement.toString().split('-')[0]);\n    this._renderer.addClass(this._element.nativeElement, 'bs-popover-' + this.placement.toString());\n  };\n  NgbPopoverWindow.decorators = [{\n    type: Component,\n    args: [{\n      selector: 'ngb-popover-window',\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      host: {\n        '[class]': '\"popover bs-popover-\" + placement.split(\"-\")[0]+\" bs-popover-\" + placement',\n        'role': 'tooltip',\n        '[id]': 'id'\n      },\n      template: \"\\n    <div class=\\\"arrow\\\"></div>\\n    <h3 class=\\\"popover-header\\\">{{title}}</h3><div class=\\\"popover-body\\\"><ng-content></ng-content></div>\",\n      styles: [\"\\n    :host.bs-popover-top .arrow, :host.bs-popover-bottom .arrow {\\n      left: 50%;\\n      margin-left: -5px;\\n    }\\n\\n    :host.bs-popover-top-left .arrow, :host.bs-popover-bottom-left .arrow {\\n      left: 2em;\\n    }\\n\\n    :host.bs-popover-top-right .arrow, :host.bs-popover-bottom-right .arrow {\\n      left: auto;\\n      right: 2em;\\n    }\\n\\n    :host.bs-popover-left .arrow, :host.bs-popover-right .arrow {\\n      top: 50%;\\n      margin-top: -5px;\\n    }\\n\\n    :host.bs-popover-left-top .arrow, :host.bs-popover-right-top .arrow {\\n      top: 0.7em;\\n    }\\n\\n    :host.bs-popover-left-bottom .arrow, :host.bs-popover-right-bottom .arrow {\\n      top: auto;\\n      bottom: 0.7em;\\n    }\\n  \"]\n    }]\n  }];\n  /** @nocollapse */\n  NgbPopoverWindow.ctorParameters = function () {\n    return [{\n      type: ElementRef\n    }, {\n      type: Renderer2\n    }];\n  };\n  NgbPopoverWindow.propDecorators = {\n    \"placement\": [{\n      type: Input\n    }],\n    \"title\": [{\n      type: Input\n    }],\n    \"id\": [{\n      type: Input\n    }]\n  };\n  return NgbPopoverWindow;\n}();\nexport { NgbPopoverWindow };\n/**\n * A lightweight, extensible directive for fancy popover creation.\n */\nvar NgbPopover = /** @class */function () {\n  function NgbPopover(_elementRef, _renderer, injector, componentFactoryResolver, viewContainerRef, config, ngZone) {\n    var _this = this;\n    this._elementRef = _elementRef;\n    this._renderer = _renderer;\n    /**\n       * Emits an event when the popover is shown\n       */\n    this.shown = new EventEmitter();\n    /**\n       * Emits an event when the popover is hidden\n       */\n    this.hidden = new EventEmitter();\n    this._ngbPopoverWindowId = \"ngb-popover-\" + nextId++;\n    this.placement = config.placement;\n    this.triggers = config.triggers;\n    this.container = config.container;\n    this.disablePopover = config.disablePopover;\n    this._popupService = new PopupService(NgbPopoverWindow, injector, viewContainerRef, _renderer, componentFactoryResolver);\n    this._zoneSubscription = ngZone.onStable.subscribe(function () {\n      if (_this._windowRef) {\n        _this._windowRef.instance.applyPlacement(positionElements(_this._elementRef.nativeElement, _this._windowRef.location.nativeElement, _this.placement, _this.container === 'body'));\n      }\n    });\n  }\n  NgbPopover.prototype._isDisabled = function () {\n    if (this.disablePopover) {\n      return true;\n    }\n    if (!this.ngbPopover && !this.popoverTitle) {\n      return true;\n    }\n    return false;\n  };\n  /**\n   * Opens an element’s popover. This is considered a “manual” triggering of the popover.\n   * The context is an optional value to be injected into the popover template when it is created.\n   */\n  /**\n     * Opens an element’s popover. This is considered a “manual” triggering of the popover.\n     * The context is an optional value to be injected into the popover template when it is created.\n     */\n  NgbPopover.prototype.open =\n  /**\n  * Opens an element’s popover. This is considered a “manual” triggering of the popover.\n  * The context is an optional value to be injected into the popover template when it is created.\n  */\n  function (context) {\n    if (!this._windowRef && !this._isDisabled()) {\n      this._windowRef = this._popupService.open(this.ngbPopover, context);\n      this._windowRef.instance.title = this.popoverTitle;\n      this._windowRef.instance.id = this._ngbPopoverWindowId;\n      this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-describedby', this._ngbPopoverWindowId);\n      if (this.container === 'body') {\n        window.document.querySelector(this.container).appendChild(this._windowRef.location.nativeElement);\n      }\n      // apply styling to set basic css-classes on target element, before going for positioning\n      this._windowRef.changeDetectorRef.detectChanges();\n      this._windowRef.changeDetectorRef.markForCheck();\n      // position popover along the element\n      this._windowRef.instance.applyPlacement(positionElements(this._elementRef.nativeElement, this._windowRef.location.nativeElement, this.placement, this.container === 'body'));\n      this.shown.emit();\n    }\n  };\n  /**\n   * Closes an element’s popover. This is considered a “manual” triggering of the popover.\n   */\n  /**\n     * Closes an element’s popover. This is considered a “manual” triggering of the popover.\n     */\n  NgbPopover.prototype.close =\n  /**\n  * Closes an element’s popover. This is considered a “manual” triggering of the popover.\n  */\n  function () {\n    if (this._windowRef) {\n      this._renderer.removeAttribute(this._elementRef.nativeElement, 'aria-describedby');\n      this._popupService.close();\n      this._windowRef = null;\n      this.hidden.emit();\n    }\n  };\n  /**\n   * Toggles an element’s popover. This is considered a “manual” triggering of the popover.\n   */\n  /**\n     * Toggles an element’s popover. This is considered a “manual” triggering of the popover.\n     */\n  NgbPopover.prototype.toggle =\n  /**\n  * Toggles an element’s popover. This is considered a “manual” triggering of the popover.\n  */\n  function () {\n    if (this._windowRef) {\n      this.close();\n    } else {\n      this.open();\n    }\n  };\n  /**\n   * Returns whether or not the popover is currently being shown\n   */\n  /**\n     * Returns whether or not the popover is currently being shown\n     */\n  NgbPopover.prototype.isOpen =\n  /**\n  * Returns whether or not the popover is currently being shown\n  */\n  function () {\n    return this._windowRef != null;\n  };\n  NgbPopover.prototype.ngOnInit = function () {\n    this._unregisterListenersFn = listenToTriggers(this._renderer, this._elementRef.nativeElement, this.triggers, this.open.bind(this), this.close.bind(this), this.toggle.bind(this));\n  };\n  NgbPopover.prototype.ngOnChanges = function (changes) {\n    // close popover if title and content become empty, or disablePopover set to true\n    if ((changes['ngbPopover'] || changes['popoverTitle'] || changes['disablePopover']) && this._isDisabled()) {\n      this.close();\n    }\n  };\n  NgbPopover.prototype.ngOnDestroy = function () {\n    this.close();\n    this._unregisterListenersFn();\n    this._zoneSubscription.unsubscribe();\n  };\n  NgbPopover.decorators = [{\n    type: Directive,\n    args: [{\n      selector: '[ngbPopover]',\n      exportAs: 'ngbPopover'\n    }]\n  }];\n  /** @nocollapse */\n  NgbPopover.ctorParameters = function () {\n    return [{\n      type: ElementRef\n    }, {\n      type: Renderer2\n    }, {\n      type: Injector\n    }, {\n      type: ComponentFactoryResolver\n    }, {\n      type: ViewContainerRef\n    }, {\n      type: NgbPopoverConfig\n    }, {\n      type: NgZone\n    }];\n  };\n  NgbPopover.propDecorators = {\n    \"ngbPopover\": [{\n      type: Input\n    }],\n    \"popoverTitle\": [{\n      type: Input\n    }],\n    \"placement\": [{\n      type: Input\n    }],\n    \"triggers\": [{\n      type: Input\n    }],\n    \"container\": [{\n      type: Input\n    }],\n    \"disablePopover\": [{\n      type: Input\n    }],\n    \"shown\": [{\n      type: Output\n    }],\n    \"hidden\": [{\n      type: Output\n    }]\n  };\n  return NgbPopover;\n}();\nexport { NgbPopover };\n//# sourceMappingURL=popover.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}