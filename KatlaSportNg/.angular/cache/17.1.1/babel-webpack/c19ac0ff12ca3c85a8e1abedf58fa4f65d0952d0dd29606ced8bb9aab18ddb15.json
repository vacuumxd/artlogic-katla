{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { forwardRef, Inject, Directive, Input, Output, EventEmitter, ElementRef, ContentChild, NgZone, Renderer2 } from '@angular/core';\nimport { NgbDropdownConfig } from './dropdown-config';\nimport { positionElements } from '../util/positioning';\n/**\n */\nvar NgbDropdownMenu = /** @class */function () {\n  function NgbDropdownMenu(dropdown, _elementRef, _renderer) {\n    this.dropdown = dropdown;\n    this._elementRef = _elementRef;\n    this._renderer = _renderer;\n    this.placement = 'bottom';\n    this.isOpen = false;\n  }\n  NgbDropdownMenu.prototype.isEventFrom = function ($event) {\n    return this._elementRef.nativeElement.contains($event.target);\n  };\n  NgbDropdownMenu.prototype.position = function (triggerEl, placement) {\n    this.applyPlacement(positionElements(triggerEl, this._elementRef.nativeElement, placement));\n  };\n  NgbDropdownMenu.prototype.applyPlacement = function (_placement) {\n    // remove the current placement classes\n    this._renderer.removeClass(this._elementRef.nativeElement.parentNode, 'dropup');\n    this._renderer.removeClass(this._elementRef.nativeElement.parentNode, 'dropdown');\n    this.placement = _placement;\n    /**\n         * apply the new placement\n         * in case of top use up-arrow or down-arrow otherwise\n         */\n    if (_placement.search('^top') !== -1) {\n      this._renderer.addClass(this._elementRef.nativeElement.parentNode, 'dropup');\n    } else {\n      this._renderer.addClass(this._elementRef.nativeElement.parentNode, 'dropdown');\n    }\n  };\n  NgbDropdownMenu.decorators = [{\n    type: Directive,\n    args: [{\n      selector: '[ngbDropdownMenu]',\n      host: {\n        '[class.dropdown-menu]': 'true',\n        '[class.show]': 'dropdown.isOpen()',\n        '[attr.x-placement]': 'placement'\n      }\n    }]\n  }];\n  /** @nocollapse */\n  NgbDropdownMenu.ctorParameters = function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [forwardRef(function () {\n          return NgbDropdown;\n        })]\n      }]\n    }, {\n      type: ElementRef\n    }, {\n      type: Renderer2\n    }];\n  };\n  return NgbDropdownMenu;\n}();\nexport { NgbDropdownMenu };\n/**\n * Marks an element to which dropdown menu will be anchored. This is a simple version\n * of the NgbDropdownToggle directive. It plays the same role as NgbDropdownToggle but\n * doesn't listen to click events to toggle dropdown menu thus enabling support for\n * events other than click.\n *\n * @since 1.1.0\n */\nvar NgbDropdownAnchor = /** @class */function () {\n  function NgbDropdownAnchor(dropdown, _elementRef) {\n    this.dropdown = dropdown;\n    this._elementRef = _elementRef;\n    this.anchorEl = _elementRef.nativeElement;\n  }\n  NgbDropdownAnchor.prototype.isEventFrom = function ($event) {\n    return this._elementRef.nativeElement.contains($event.target);\n  };\n  NgbDropdownAnchor.decorators = [{\n    type: Directive,\n    args: [{\n      selector: '[ngbDropdownAnchor]',\n      host: {\n        'class': 'dropdown-toggle',\n        'aria-haspopup': 'true',\n        '[attr.aria-expanded]': 'dropdown.isOpen()'\n      }\n    }]\n  }];\n  /** @nocollapse */\n  NgbDropdownAnchor.ctorParameters = function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [forwardRef(function () {\n          return NgbDropdown;\n        })]\n      }]\n    }, {\n      type: ElementRef\n    }];\n  };\n  return NgbDropdownAnchor;\n}();\nexport { NgbDropdownAnchor };\n/**\n * Allows the dropdown to be toggled via click. This directive is optional: you can use NgbDropdownAnchor as an\n * alternative.\n */\nvar NgbDropdownToggle = /** @class */function (_super) {\n  __extends(NgbDropdownToggle, _super);\n  function NgbDropdownToggle(dropdown, elementRef) {\n    return _super.call(this, dropdown, elementRef) || this;\n  }\n  NgbDropdownToggle.prototype.toggleOpen = function () {\n    this.dropdown.toggle();\n  };\n  NgbDropdownToggle.decorators = [{\n    type: Directive,\n    args: [{\n      selector: '[ngbDropdownToggle]',\n      host: {\n        'class': 'dropdown-toggle',\n        'aria-haspopup': 'true',\n        '[attr.aria-expanded]': 'dropdown.isOpen()',\n        '(click)': 'toggleOpen()'\n      },\n      providers: [{\n        provide: NgbDropdownAnchor,\n        useExisting: forwardRef(function () {\n          return NgbDropdownToggle;\n        })\n      }]\n    }]\n  }];\n  /** @nocollapse */\n  NgbDropdownToggle.ctorParameters = function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [forwardRef(function () {\n          return NgbDropdown;\n        })]\n      }]\n    }, {\n      type: ElementRef\n    }];\n  };\n  return NgbDropdownToggle;\n}(NgbDropdownAnchor);\nexport { NgbDropdownToggle };\n/**\n * Transforms a node into a dropdown.\n */\nvar NgbDropdown = /** @class */function () {\n  function NgbDropdown(config, ngZone) {\n    var _this = this;\n    /**\n       *  Defines whether or not the dropdown-menu is open initially.\n       */\n    this._open = false;\n    /**\n       *  An event fired when the dropdown is opened or closed.\n       *  Event's payload equals whether dropdown is open.\n       */\n    this.openChange = new EventEmitter();\n    this.placement = config.placement;\n    this.autoClose = config.autoClose;\n    this._zoneSubscription = ngZone.onStable.subscribe(function () {\n      _this._positionMenu();\n    });\n  }\n  NgbDropdown.prototype.ngOnInit = function () {\n    if (this._menu) {\n      this._menu.applyPlacement(Array.isArray(this.placement) ? this.placement[0] : this.placement);\n    }\n  };\n  /**\n   * Checks if the dropdown menu is open or not.\n   */\n  /**\n     * Checks if the dropdown menu is open or not.\n     */\n  NgbDropdown.prototype.isOpen =\n  /**\n  * Checks if the dropdown menu is open or not.\n  */\n  function () {\n    return this._open;\n  };\n  /**\n   * Opens the dropdown menu of a given navbar or tabbed navigation.\n   */\n  /**\n     * Opens the dropdown menu of a given navbar or tabbed navigation.\n     */\n  NgbDropdown.prototype.open =\n  /**\n  * Opens the dropdown menu of a given navbar or tabbed navigation.\n  */\n  function () {\n    if (!this._open) {\n      this._open = true;\n      this._positionMenu();\n      this.openChange.emit(true);\n    }\n  };\n  /**\n   * Closes the dropdown menu of a given navbar or tabbed navigation.\n   */\n  /**\n     * Closes the dropdown menu of a given navbar or tabbed navigation.\n     */\n  NgbDropdown.prototype.close =\n  /**\n  * Closes the dropdown menu of a given navbar or tabbed navigation.\n  */\n  function () {\n    if (this._open) {\n      this._open = false;\n      this.openChange.emit(false);\n    }\n  };\n  /**\n   * Toggles the dropdown menu of a given navbar or tabbed navigation.\n   */\n  /**\n     * Toggles the dropdown menu of a given navbar or tabbed navigation.\n     */\n  NgbDropdown.prototype.toggle =\n  /**\n  * Toggles the dropdown menu of a given navbar or tabbed navigation.\n  */\n  function () {\n    if (this.isOpen()) {\n      this.close();\n    } else {\n      this.open();\n    }\n  };\n  NgbDropdown.prototype.closeFromClick = function ($event) {\n    if (this.autoClose && $event.button !== 2 && !this._isEventFromToggle($event)) {\n      if (this.autoClose === true) {\n        this.close();\n      } else if (this.autoClose === 'inside' && this._isEventFromMenu($event)) {\n        this.close();\n      } else if (this.autoClose === 'outside' && !this._isEventFromMenu($event)) {\n        this.close();\n      }\n    }\n  };\n  NgbDropdown.prototype.closeFromOutsideEsc = function () {\n    if (this.autoClose) {\n      this.close();\n    }\n  };\n  NgbDropdown.prototype.ngOnDestroy = function () {\n    this._zoneSubscription.unsubscribe();\n  };\n  NgbDropdown.prototype._isEventFromToggle = function ($event) {\n    return this._anchor.isEventFrom($event);\n  };\n  NgbDropdown.prototype._isEventFromMenu = function ($event) {\n    return this._menu ? this._menu.isEventFrom($event) : false;\n  };\n  NgbDropdown.prototype._positionMenu = function () {\n    if (this.isOpen() && this._menu) {\n      this._menu.position(this._anchor.anchorEl, this.placement);\n    }\n  };\n  NgbDropdown.decorators = [{\n    type: Directive,\n    args: [{\n      selector: '[ngbDropdown]',\n      exportAs: 'ngbDropdown',\n      host: {\n        '[class.show]': 'isOpen()',\n        '(keyup.esc)': 'closeFromOutsideEsc()',\n        '(document:click)': 'closeFromClick($event)'\n      }\n    }]\n  }];\n  /** @nocollapse */\n  NgbDropdown.ctorParameters = function () {\n    return [{\n      type: NgbDropdownConfig\n    }, {\n      type: NgZone\n    }];\n  };\n  NgbDropdown.propDecorators = {\n    \"_menu\": [{\n      type: ContentChild,\n      args: [NgbDropdownMenu]\n    }],\n    \"_anchor\": [{\n      type: ContentChild,\n      args: [NgbDropdownAnchor]\n    }],\n    \"autoClose\": [{\n      type: Input\n    }],\n    \"_open\": [{\n      type: Input,\n      args: ['open']\n    }],\n    \"placement\": [{\n      type: Input\n    }],\n    \"openChange\": [{\n      type: Output\n    }]\n  };\n  return NgbDropdown;\n}();\nexport { NgbDropdown };\n//# sourceMappingURL=dropdown.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}