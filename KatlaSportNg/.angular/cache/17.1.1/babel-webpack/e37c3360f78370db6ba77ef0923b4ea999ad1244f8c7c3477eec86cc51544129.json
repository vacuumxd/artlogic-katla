{"ast":null,"code":"import { NgbCalendar } from './ngb-calendar';\nimport { NgbDate } from './ngb-date';\nimport { Injectable } from '@angular/core';\nimport { isInteger, toInteger } from '../util/util';\nimport { Subject } from 'rxjs';\nimport { buildMonths, checkDateInRange, checkMinBeforeMax, isChangedDate, isDateSelectable, generateSelectBoxYears, generateSelectBoxMonths, prevMonthDisabled, nextMonthDisabled } from './datepicker-tools';\nimport { filter } from 'rxjs/operators';\nimport { NgbDatepickerI18n } from './datepicker-i18n';\nvar NgbDatepickerService = /** @class */function () {\n  function NgbDatepickerService(_calendar, _i18n) {\n    this._calendar = _calendar;\n    this._i18n = _i18n;\n    this._model$ = new Subject();\n    this._select$ = new Subject();\n    this._state = {\n      disabled: false,\n      displayMonths: 1,\n      firstDayOfWeek: 1,\n      focusVisible: false,\n      months: [],\n      navigation: 'select',\n      prevDisabled: false,\n      nextDisabled: false,\n      selectBoxes: {\n        years: [],\n        months: []\n      },\n      selectedDate: null\n    };\n  }\n  Object.defineProperty(NgbDatepickerService.prototype, \"model$\", {\n    get: function () {\n      return this._model$.pipe(filter(function (model) {\n        return model.months.length > 0;\n      }));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NgbDatepickerService.prototype, \"select$\", {\n    get: function () {\n      return this._select$.pipe(filter(function (date) {\n        return date !== null;\n      }));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NgbDatepickerService.prototype, \"disabled\", {\n    set: function (disabled) {\n      if (this._state.disabled !== disabled) {\n        this._nextState({\n          disabled: disabled\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NgbDatepickerService.prototype, \"displayMonths\", {\n    set: function (displayMonths) {\n      displayMonths = toInteger(displayMonths);\n      if (isInteger(displayMonths) && displayMonths > 0 && this._state.displayMonths !== displayMonths) {\n        this._nextState({\n          displayMonths: displayMonths\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NgbDatepickerService.prototype, \"firstDayOfWeek\", {\n    set: function (firstDayOfWeek) {\n      firstDayOfWeek = toInteger(firstDayOfWeek);\n      if (isInteger(firstDayOfWeek) && firstDayOfWeek >= 0 && this._state.firstDayOfWeek !== firstDayOfWeek) {\n        this._nextState({\n          firstDayOfWeek: firstDayOfWeek\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NgbDatepickerService.prototype, \"focusVisible\", {\n    set: function (focusVisible) {\n      if (this._state.focusVisible !== focusVisible && !this._state.disabled) {\n        this._nextState({\n          focusVisible: focusVisible\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NgbDatepickerService.prototype, \"maxDate\", {\n    set: function (date) {\n      var maxDate = this.toValidDate(date, null);\n      if (isChangedDate(this._state.maxDate, maxDate)) {\n        this._nextState({\n          maxDate: maxDate\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NgbDatepickerService.prototype, \"markDisabled\", {\n    set: function (markDisabled) {\n      if (this._state.markDisabled !== markDisabled) {\n        this._nextState({\n          markDisabled: markDisabled\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NgbDatepickerService.prototype, \"minDate\", {\n    set: function (date) {\n      var minDate = this.toValidDate(date, null);\n      if (isChangedDate(this._state.minDate, minDate)) {\n        this._nextState({\n          minDate: minDate\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NgbDatepickerService.prototype, \"navigation\", {\n    set: function (navigation) {\n      if (this._state.navigation !== navigation) {\n        this._nextState({\n          navigation: navigation\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  NgbDatepickerService.prototype.focus = function (date) {\n    if (!this._state.disabled && this._calendar.isValid(date) && isChangedDate(this._state.focusDate, date)) {\n      this._nextState({\n        focusDate: date\n      });\n    }\n  };\n  NgbDatepickerService.prototype.focusMove = function (period, number) {\n    this.focus(this._calendar.getNext(this._state.focusDate, period, number));\n  };\n  NgbDatepickerService.prototype.focusSelect = function () {\n    if (isDateSelectable(this._state.focusDate, this._state)) {\n      this.select(this._state.focusDate, {\n        emitEvent: true\n      });\n    }\n  };\n  NgbDatepickerService.prototype.open = function (date) {\n    var firstDate = this.toValidDate(date, this._calendar.getToday());\n    if (!this._state.disabled) {\n      this._nextState({\n        firstDate: firstDate\n      });\n    }\n  };\n  NgbDatepickerService.prototype.select = function (date, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var selectedDate = this.toValidDate(date, null);\n    if (!this._state.disabled) {\n      if (isChangedDate(this._state.selectedDate, selectedDate)) {\n        this._nextState({\n          selectedDate: selectedDate\n        });\n      }\n      if (options.emitEvent && isDateSelectable(selectedDate, this._state)) {\n        this._select$.next(selectedDate);\n      }\n    }\n  };\n  NgbDatepickerService.prototype.toValidDate = function (date, defaultValue) {\n    var ngbDate = NgbDate.from(date);\n    if (defaultValue === undefined) {\n      defaultValue = this._calendar.getToday();\n    }\n    return this._calendar.isValid(ngbDate) ? ngbDate : defaultValue;\n  };\n  NgbDatepickerService.prototype._nextState = function (patch) {\n    var newState = this._updateState(patch);\n    this._patchContexts(newState);\n    this._state = newState;\n    this._model$.next(this._state);\n  };\n  NgbDatepickerService.prototype._patchContexts = function (state) {\n    state.months.forEach(function (month) {\n      month.weeks.forEach(function (week) {\n        week.days.forEach(function (day) {\n          // patch focus flag\n          if (state.focusDate) {\n            day.context.focused = state.focusDate.equals(day.date) && state.focusVisible;\n          }\n          day.tabindex = !state.disabled && day.date.equals(state.focusDate) && state.focusDate.month === month.number ? 0 : -1;\n          // override context disabled\n          if (state.disabled === true) {\n            day.context.disabled = true;\n          }\n          // patch selection flag\n          if (state.selectedDate !== undefined) {\n            day.context.selected = state.selectedDate !== null && state.selectedDate.equals(day.date);\n          }\n        });\n      });\n    });\n  };\n  NgbDatepickerService.prototype._updateState = function (patch) {\n    // patching fields\n    var state = Object.assign({}, this._state, patch);\n    var startDate = state.firstDate;\n    // min/max dates changed\n    if ('minDate' in patch || 'maxDate' in patch) {\n      checkMinBeforeMax(state.minDate, state.maxDate);\n      state.focusDate = checkDateInRange(state.focusDate, state.minDate, state.maxDate);\n      state.firstDate = checkDateInRange(state.firstDate, state.minDate, state.maxDate);\n      startDate = state.focusDate;\n    }\n    // disabled\n    if ('disabled' in patch) {\n      state.focusVisible = false;\n    }\n    // initial rebuild via 'select()'\n    if ('selectedDate' in patch && this._state.months.length === 0) {\n      startDate = state.selectedDate;\n    }\n    // focus date changed\n    if ('focusDate' in patch) {\n      state.focusDate = checkDateInRange(state.focusDate, state.minDate, state.maxDate);\n      startDate = state.focusDate;\n      // nothing to rebuild if only focus changed and it is still visible\n      if (state.months.length !== 0 && !state.focusDate.before(state.firstDate) && !state.focusDate.after(state.lastDate)) {\n        return state;\n      }\n    }\n    // first date changed\n    if ('firstDate' in patch) {\n      state.firstDate = checkDateInRange(state.firstDate, state.minDate, state.maxDate);\n      startDate = state.firstDate;\n    }\n    // rebuilding months\n    if (startDate) {\n      var forceRebuild = 'firstDayOfWeek' in patch || 'markDisabled' in patch || 'minDate' in patch || 'maxDate' in patch || 'disabled' in patch;\n      var months = buildMonths(this._calendar, startDate, state, this._i18n, forceRebuild);\n      // updating months and boundary dates\n      state.months = months;\n      state.firstDate = months.length > 0 ? months[0].firstDate : undefined;\n      state.lastDate = months.length > 0 ? months[months.length - 1].lastDate : undefined;\n      // reset selected date if 'markDisabled' returns true\n      if ('selectedDate' in patch && !isDateSelectable(state.selectedDate, state)) {\n        state.selectedDate = null;\n      }\n      // adjusting focus after months were built\n      if ('firstDate' in patch) {\n        if (state.focusDate === undefined || state.focusDate.before(state.firstDate) || state.focusDate.after(state.lastDate)) {\n          state.focusDate = startDate;\n        }\n      }\n      // adjusting months/years for the select box navigation\n      var yearChanged = !this._state.firstDate || this._state.firstDate.year !== state.firstDate.year;\n      var monthChanged = !this._state.firstDate || this._state.firstDate.month !== state.firstDate.month;\n      if (state.navigation === 'select') {\n        // years ->  boundaries (min/max were changed)\n        if ('minDate' in patch || 'maxDate' in patch || state.selectBoxes.years.length === 0 || yearChanged) {\n          state.selectBoxes.years = generateSelectBoxYears(state.focusDate, state.minDate, state.maxDate);\n        }\n        // months -> when current year or boundaries change\n        if ('minDate' in patch || 'maxDate' in patch || state.selectBoxes.months.length === 0 || yearChanged) {\n          state.selectBoxes.months = generateSelectBoxMonths(this._calendar, state.focusDate, state.minDate, state.maxDate);\n        }\n      } else {\n        state.selectBoxes = {\n          years: [],\n          months: []\n        };\n      }\n      // updating navigation arrows -> boundaries change (min/max) or month/year changes\n      if ((state.navigation === 'arrows' || state.navigation === 'select') && (monthChanged || yearChanged || 'minDate' in patch || 'maxDate' in patch || 'disabled' in patch)) {\n        state.prevDisabled = state.disabled || prevMonthDisabled(this._calendar, state.firstDate, state.minDate);\n        state.nextDisabled = state.disabled || nextMonthDisabled(this._calendar, state.lastDate, state.maxDate);\n      }\n    }\n    return state;\n  };\n  NgbDatepickerService.decorators = [{\n    type: Injectable\n  }];\n  /** @nocollapse */\n  NgbDatepickerService.ctorParameters = function () {\n    return [{\n      type: NgbCalendar\n    }, {\n      type: NgbDatepickerI18n\n    }];\n  };\n  return NgbDatepickerService;\n}();\nexport { NgbDatepickerService };\n//# sourceMappingURL=datepicker-service.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}