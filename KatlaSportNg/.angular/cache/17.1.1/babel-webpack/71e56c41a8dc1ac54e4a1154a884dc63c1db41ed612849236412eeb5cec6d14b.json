{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { padNumber, toInteger, isNumber } from '../util/util';\n/**\n * Abstract type serving as a DI token for the service parsing and formatting dates for the NgbInputDatepicker\n * directive. A default implementation using the ISO 8601 format is provided, but you can provide another implementation\n * to use an alternative format.\n */\nvar\n/**\n* Abstract type serving as a DI token for the service parsing and formatting dates for the NgbInputDatepicker\n* directive. A default implementation using the ISO 8601 format is provided, but you can provide another implementation\n* to use an alternative format.\n*/\nNgbDateParserFormatter = /** @class */function () {\n  function NgbDateParserFormatter() {}\n  return NgbDateParserFormatter;\n}();\n/**\n * Abstract type serving as a DI token for the service parsing and formatting dates for the NgbInputDatepicker\n * directive. A default implementation using the ISO 8601 format is provided, but you can provide another implementation\n * to use an alternative format.\n */\nexport { NgbDateParserFormatter };\nvar NgbDateISOParserFormatter = /** @class */function (_super) {\n  __extends(NgbDateISOParserFormatter, _super);\n  function NgbDateISOParserFormatter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  NgbDateISOParserFormatter.prototype.parse = function (value) {\n    if (value) {\n      var dateParts = value.trim().split('-');\n      if (dateParts.length === 1 && isNumber(dateParts[0])) {\n        return {\n          year: toInteger(dateParts[0]),\n          month: null,\n          day: null\n        };\n      } else if (dateParts.length === 2 && isNumber(dateParts[0]) && isNumber(dateParts[1])) {\n        return {\n          year: toInteger(dateParts[0]),\n          month: toInteger(dateParts[1]),\n          day: null\n        };\n      } else if (dateParts.length === 3 && isNumber(dateParts[0]) && isNumber(dateParts[1]) && isNumber(dateParts[2])) {\n        return {\n          year: toInteger(dateParts[0]),\n          month: toInteger(dateParts[1]),\n          day: toInteger(dateParts[2])\n        };\n      }\n    }\n    return null;\n  };\n  NgbDateISOParserFormatter.prototype.format = function (date) {\n    return date ? date.year + \"-\" + (isNumber(date.month) ? padNumber(date.month) : '') + \"-\" + (isNumber(date.day) ? padNumber(date.day) : '') : '';\n  };\n  return NgbDateISOParserFormatter;\n}(NgbDateParserFormatter);\nexport { NgbDateISOParserFormatter };\n//# sourceMappingURL=ngb-date-parser-formatter.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}